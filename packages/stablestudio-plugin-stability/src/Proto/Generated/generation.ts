// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "generation.proto" (package "gooseai", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Struct } from "./google/protobuf/struct";
import { Tensor } from "./tensors";
/**
 * Generally, a GPT BPE 16-bit token, paired with an optional string representation.
 *
 * @generated from protobuf message gooseai.Token
 */
export interface Token {
    /**
     * @generated from protobuf field: optional string text = 1;
     */
    text?: string;
    /**
     * @generated from protobuf field: uint32 id = 2;
     */
    id: number;
}
/**
 * Sequence of tokens, paired with the id of the tokenizer used to generate them.
 *
 * @generated from protobuf message gooseai.Tokens
 */
export interface Tokens {
    /**
     * @generated from protobuf field: repeated gooseai.Token tokens = 1;
     */
    tokens: Token[];
    /**
     * @generated from protobuf field: optional string tokenizer_id = 2;
     */
    tokenizerId?: string;
}
/**
 * A tangible Artifact, such as an image, video, or text that is used for input
 * or output.
 *
 * @generated from protobuf message gooseai.Artifact
 */
export interface Artifact {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: gooseai.ArtifactType type = 2;
     */
    type: ArtifactType;
    /**
     * @generated from protobuf field: string mime = 3;
     */
    mime: string; // MIME type identifier, e.g. "image/png"
    /**
     * @generated from protobuf field: optional string magic = 4;
     */
    magic?: string; // Magic number, e.g. "PNG"
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "binary";
        /**
         * @generated from protobuf field: bytes binary = 5;
         */
        binary: Uint8Array; // Binary data, e.g. PNG image
    } | {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 6;
         */
        text: string; // Text data, e.g. text prompt
    } | {
        oneofKind: "tokens";
        /**
         * @generated from protobuf field: gooseai.Tokens tokens = 7;
         */
        tokens: Tokens; // Tokenized text data, e.g. GPT tokens
    } | {
        oneofKind: "classifier";
        /**
         * @generated from protobuf field: gooseai.ClassifierParameters classifier = 11;
         */
        classifier: ClassifierParameters;
    } | {
        oneofKind: "tensor";
        /**
         * @generated from protobuf field: tensors.Tensor tensor = 14;
         */
        tensor: Tensor; // torch.Tensor:
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: uint32 index = 8;
     */
    index: number; // Index of this artifact in input/output list
    /**
     * @generated from protobuf field: gooseai.FinishReason finish_reason = 9;
     */
    finishReason: FinishReason; // Reason for finishing, if applicable
    /**
     * @generated from protobuf field: uint32 seed = 10;
     */
    seed: number; // Seed used to generate this artifact
    /**
     * @generated from protobuf field: string uuid = 12;
     */
    uuid: string; // UUIDv4 of the artifact, used for asset lookup
    /**
     * @generated from protobuf field: uint64 size = 13;
     */
    size: bigint; // Size of the artifact in bytes
}
/**
 * A set of parameters for each individual Prompt.
 *
 * @generated from protobuf message gooseai.PromptParameters
 */
export interface PromptParameters {
    /**
     * @generated from protobuf field: optional bool init = 1;
     */
    init?: boolean; // deprecated, no longer used
    /**
     * @generated from protobuf field: optional float weight = 2;
     */
    weight?: number;
}
/**
 * A Prompt is a special type of Artifact that is used to generate an output.
 * There can be multiple Prompts that affect the same output. Currently, the
 * only Prompts supported are:
 *   - Text (singular)
 *   - Init Image (singular, optional, type ARTIFACT_IMAGE)
 *   - Mask (singular, optional, type ARTIFACT_MASK)
 *   - Depth (singular, optional, type ARTIFACT_DEPTH)
 *
 * @generated from protobuf message gooseai.Prompt
 */
export interface Prompt {
    /**
     * @generated from protobuf field: optional gooseai.PromptParameters parameters = 1;
     */
    parameters?: PromptParameters;
    /**
     * @generated from protobuf oneof: prompt
     */
    prompt: {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 2;
         */
        text: string;
    } | {
        oneofKind: "tokens";
        /**
         * @generated from protobuf field: gooseai.Tokens tokens = 3;
         */
        tokens: Tokens;
    } | {
        oneofKind: "artifact";
        /**
         * @generated from protobuf field: gooseai.Artifact artifact = 4;
         */
        artifact: Artifact;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Parameters that affect the behavior of the sampler, typically used for CFG.
 *
 * @generated from protobuf message gooseai.SamplerParameters
 */
export interface SamplerParameters {
    /**
     * @generated from protobuf field: optional float eta = 1;
     */
    eta?: number;
    /**
     * @generated from protobuf field: optional uint64 sampling_steps = 2;
     */
    samplingSteps?: bigint;
    /**
     * @generated from protobuf field: optional uint64 latent_channels = 3;
     */
    latentChannels?: bigint;
    /**
     * @generated from protobuf field: optional uint64 downsampling_factor = 4;
     */
    downsamplingFactor?: bigint;
    /**
     * @generated from protobuf field: optional float cfg_scale = 5;
     */
    cfgScale?: number;
    /**
     * @generated from protobuf field: optional float init_noise_scale = 6;
     */
    initNoiseScale?: number; // defaults to 0.99
    /**
     * @generated from protobuf field: optional float step_noise_scale = 7;
     */
    stepNoiseScale?: number; // defaults to 0.99
}
/**
 * Unused, but reserved for future use. Adjustments to the latents after
 * initialization.
 *
 * @generated from protobuf message gooseai.ConditionerParameters
 */
export interface ConditionerParameters {
    /**
     * @generated from protobuf field: optional string vector_adjust_prior = 1;
     */
    vectorAdjustPrior?: string;
    /**
     * @generated from protobuf field: optional gooseai.Model conditioner = 2;
     */
    conditioner?: Model;
}
/**
 * When does this schedule definition apply?
 *
 * @generated from protobuf message gooseai.ScheduleParameters
 */
export interface ScheduleParameters {
    /**
     * @generated from protobuf field: optional float start = 1;
     */
    start?: number; // 0.0 to 1.0
    /**
     * @generated from protobuf field: optional float end = 2;
     */
    end?: number; // 0.0 to 1.0
    /**
     * @generated from protobuf field: optional float value = 3;
     */
    value?: number; // float value to apply on this schedule
}
/**
 * Parameters that apply to this block of the schedule.
 *
 * @generated from protobuf message gooseai.StepParameter
 */
export interface StepParameter {
    /**
     * @generated from protobuf field: float scaled_step = 1;
     */
    scaledStep: number;
    /**
     * @generated from protobuf field: optional gooseai.SamplerParameters sampler = 2;
     */
    sampler?: SamplerParameters;
    /**
     * @generated from protobuf field: optional gooseai.ScheduleParameters schedule = 3;
     */
    schedule?: ScheduleParameters;
    /**
     * @generated from protobuf field: optional gooseai.GuidanceParameters guidance = 4;
     */
    guidance?: GuidanceParameters;
}
/**
 * @generated from protobuf message gooseai.Model
 */
export interface Model {
    /**
     * @generated from protobuf field: gooseai.ModelArchitecture architecture = 1;
     */
    architecture: ModelArchitecture;
    /**
     * @generated from protobuf field: string publisher = 2;
     */
    publisher: string;
    /**
     * @generated from protobuf field: string dataset = 3;
     */
    dataset: string;
    /**
     * @generated from protobuf field: float version = 4;
     */
    version: number;
    /**
     * @generated from protobuf field: string semantic_version = 5;
     */
    semanticVersion: string;
    /**
     * @generated from protobuf field: string alias = 6;
     */
    alias: string;
}
/**
 * @generated from protobuf message gooseai.CutoutParameters
 */
export interface CutoutParameters {
    /**
     * @generated from protobuf field: repeated gooseai.CutoutParameters cutouts = 1;
     */
    cutouts: CutoutParameters[]; // Nested cutouts, unsupported
    /**
     * @generated from protobuf field: optional uint32 count = 2;
     */
    count?: number; // 0 to n, usually 8 to 32, 0 inner
    /**
     * @generated from protobuf field: optional float gray = 3;
     */
    gray?: number; // 0.0 to 1.0, defaults to 0.2
    /**
     * @generated from protobuf field: optional float blur = 4;
     */
    blur?: number; // percentage of cutouts to blur
    /**
     * @generated from protobuf field: optional float size_power = 5;
     */
    sizePower?: number; // defaults to inner: 0.5, outer: 0.0
}
/**
 * GuidanceScheduleParameters are used to define a schedule for CLIP guidance, and
 * are used to define the behavior of the guidance over time. They are relative
 * to the total number of steps, and are scaled to the number of steps in the
 * current run.
 *
 * @generated from protobuf message gooseai.GuidanceScheduleParameters
 */
export interface GuidanceScheduleParameters {
    /**
     * @generated from protobuf field: float duration = 1;
     */
    duration: number;
    /**
     * @generated from protobuf field: float value = 2;
     */
    value: number;
}
/**
 * Parameters that affect the behavior of the guidance, typically used for CLIP.
 * We can specify more than one model, and the guidance will be a weighted sum
 * of the models.
 *
 * @generated from protobuf message gooseai.GuidanceInstanceParameters
 */
export interface GuidanceInstanceParameters {
    /**
     * @generated from protobuf field: repeated gooseai.Model models = 2;
     */
    models: Model[]; // models to use for this set
    /**
     * @generated from protobuf field: optional float guidance_strength = 3;
     */
    guidanceStrength?: number; // 0.0 to 1.0, usually 0.05 to 0.225
    /**
     * @generated from protobuf field: repeated gooseai.GuidanceScheduleParameters schedule = 4;
     */
    schedule: GuidanceScheduleParameters[]; // when to apply guidance
    /**
     * @generated from protobuf field: optional gooseai.CutoutParameters cutouts = 5;
     */
    cutouts?: CutoutParameters; // cutout parameters
    /**
     * @generated from protobuf field: optional gooseai.Prompt prompt = 6;
     */
    prompt?: Prompt; // prompt to use for guidance
}
/**
 * Parameters that affect the behavior of the guidance, typically used for CLIP.
 * The omission of this field implies the default guidance of CFG.
 *
 * @generated from protobuf message gooseai.GuidanceParameters
 */
export interface GuidanceParameters {
    /**
     * @generated from protobuf field: gooseai.GuidancePreset guidance_preset = 1;
     */
    guidancePreset: GuidancePreset; // base preset for guidance
    /**
     * @generated from protobuf field: repeated gooseai.GuidanceInstanceParameters instances = 2;
     */
    instances: GuidanceInstanceParameters[]; // guidance instances
}
/**
 * @generated from protobuf message gooseai.TransformType
 */
export interface TransformType {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "diffusion";
        /**
         * @generated from protobuf field: gooseai.DiffusionSampler diffusion = 1;
         */
        diffusion: DiffusionSampler;
    } | {
        oneofKind: "upscaler";
        /**
         * @generated from protobuf field: gooseai.Upscaler upscaler = 2;
         */
        upscaler: Upscaler;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gooseai.ImageParameters
 */
export interface ImageParameters {
    /**
     * @generated from protobuf field: optional uint64 height = 1;
     */
    height?: bigint;
    /**
     * @generated from protobuf field: optional uint64 width = 2;
     */
    width?: bigint;
    /**
     * @generated from protobuf field: repeated uint32 seed = 3;
     */
    seed: number[];
    /**
     * @generated from protobuf field: optional uint64 samples = 4;
     */
    samples?: bigint;
    /**
     * @generated from protobuf field: optional uint64 steps = 5;
     */
    steps?: bigint;
    /**
     * @generated from protobuf field: optional gooseai.TransformType transform = 6;
     */
    transform?: TransformType;
    /**
     * @generated from protobuf field: repeated gooseai.StepParameter parameters = 7;
     */
    parameters: StepParameter[];
    /**
     * @generated from protobuf field: optional gooseai.MaskedAreaInit masked_area_init = 8;
     */
    maskedAreaInit?: MaskedAreaInit; // defaults to MASKED_AREA_INIT_ZERO
    /**
     * @generated from protobuf field: optional gooseai.WeightMethod weight_method = 9;
     */
    weightMethod?: WeightMethod; // defaults to TEXT_ENCODER
    /**
     * @generated from protobuf field: optional bool quantize = 10;
     */
    quantize?: boolean; // defaults to true
}
/**
 * @generated from protobuf message gooseai.ClassifierConcept
 */
export interface ClassifierConcept {
    /**
     * @generated from protobuf field: string concept = 1;
     */
    concept: string;
    /**
     * @generated from protobuf field: optional float threshold = 2;
     */
    threshold?: number;
}
/**
 * @generated from protobuf message gooseai.ClassifierCategory
 */
export interface ClassifierCategory {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated gooseai.ClassifierConcept concepts = 2;
     */
    concepts: ClassifierConcept[];
    /**
     * @generated from protobuf field: optional float adjustment = 3;
     */
    adjustment?: number;
    /**
     * @generated from protobuf field: optional gooseai.Action action = 4;
     */
    action?: Action;
    /**
     * @generated from protobuf field: optional gooseai.ClassifierMode classifier_mode = 5;
     */
    classifierMode?: ClassifierMode;
}
/**
 * @generated from protobuf message gooseai.ClassifierParameters
 */
export interface ClassifierParameters {
    /**
     * @generated from protobuf field: repeated gooseai.ClassifierCategory categories = 1;
     */
    categories: ClassifierCategory[];
    /**
     * @generated from protobuf field: repeated gooseai.ClassifierCategory exceeds = 2;
     */
    exceeds: ClassifierCategory[];
    /**
     * @generated from protobuf field: optional gooseai.Action realized_action = 3;
     */
    realizedAction?: Action;
}
/**
 * Interpolation between two images applied at specified blend ratios
 *
 * @generated from protobuf message gooseai.InterpolateParameters
 */
export interface InterpolateParameters {
    /**
     * @generated from protobuf field: repeated float ratios = 1;
     */
    ratios: number[];
    /**
     * @generated from protobuf field: optional gooseai.InterpolateMode mode = 2;
     */
    mode?: InterpolateMode;
}
/**
 * @generated from protobuf message gooseai.TransformColorAdjust
 */
export interface TransformColorAdjust {
    /**
     * @generated from protobuf field: optional float brightness = 1;
     */
    brightness?: number; // scale pixel intensities, 1.0 is no change
    /**
     * @generated from protobuf field: optional float contrast = 2;
     */
    contrast?: number; // contrast adjustment, 1.0 is no change
    /**
     * @generated from protobuf field: optional float hue = 3;
     */
    hue?: number; // -180 to 180 hue adjustment, 0.0 is no change
    /**
     * @generated from protobuf field: optional float saturation = 4;
     */
    saturation?: number; // 0.0 to 2.0 saturation scale, 1.0 is no change
    /**
     * @generated from protobuf field: optional float lightness = 5;
     */
    lightness?: number; // -1.0 to 1.0 lightness adjustment, 0.0 is no change
    /**
     * @generated from protobuf field: optional gooseai.Artifact match_image = 6;
     */
    matchImage?: Artifact; // image to color match
    /**
     * @generated from protobuf field: optional gooseai.ColorMatchMode match_mode = 7;
     */
    matchMode?: ColorMatchMode; // color match mode to use
    /**
     * @generated from protobuf field: optional float noise_amount = 8;
     */
    noiseAmount?: number; // amount of gaussian noise to add
    /**
     * @generated from protobuf field: optional uint32 noise_seed = 9;
     */
    noiseSeed?: number; // random seed for noise
}
/**
 * @generated from protobuf message gooseai.TransformDepthCalc
 */
export interface TransformDepthCalc {
    /**
     * @generated from protobuf field: optional float blend_weight = 1;
     */
    blendWeight?: number; // blend factor between AdaBins (0.0) and MiDaS (1.0)
    /**
     * @generated from protobuf field: optional uint32 blur_radius = 2;
     */
    blurRadius?: number; // defaults to 0.0
    /**
     * @generated from protobuf field: optional bool reverse = 3;
     */
    reverse?: boolean; // make near depths have higher values
}
/**
 * @generated from protobuf message gooseai.TransformMatrix
 */
export interface TransformMatrix {
    /**
     * Column-major 3x3 or 4x4 perspective matrix
     * [sx, 10, 20, tx]   [x]
     * [01, sy, 21, ty] . [y]
     * [02, 12, sz, tz]   [z]
     * [03, 13, 23, 33]   [1]
     *
     * @generated from protobuf field: repeated float data = 1 [packed = true];
     */
    data: number[];
}
/**
 * @generated from protobuf message gooseai.TransformResample
 */
export interface TransformResample {
    /**
     * @generated from protobuf field: gooseai.BorderMode border_mode = 1;
     */
    borderMode: BorderMode; // extrapolation of border pixels
    /**
     * @generated from protobuf field: gooseai.TransformMatrix transform = 2;
     */
    transform?: TransformMatrix; // 3x3 or 4x4 matrix
    /**
     * @generated from protobuf field: optional gooseai.TransformMatrix prev_transform = 3;
     */
    prevTransform?: TransformMatrix; // 3x3 or 4x4 matrix, defaults to identity
    /**
     * @generated from protobuf field: optional float depth_warp = 4;
     */
    depthWarp?: number; // depth warp factor, defaults to 1.0
    /**
     * @generated from protobuf field: optional bool export_mask = 5;
     */
    exportMask?: boolean; // return inpaint mask
}
/**
 * @generated from protobuf message gooseai.CameraParameters
 */
export interface CameraParameters {
    /**
     * @generated from protobuf field: gooseai.CameraType camera_type = 1;
     */
    cameraType: CameraType;
    /**
     * @generated from protobuf field: float near_plane = 2;
     */
    nearPlane: number; // Nearest plane depth of a rendered frustum
    /**
     * @generated from protobuf field: float far_plane = 3;
     */
    farPlane: number; // Farthest plane depth of a rendered frustum
    /**
     * @generated from protobuf field: optional float fov = 4;
     */
    fov?: number; // Camera field of view (in degrees). Must be set for CAMERA_PERSPECTIVE type.
}
/**
 * @generated from protobuf message gooseai.TransformCameraPose
 */
export interface TransformCameraPose {
    /**
     * @generated from protobuf field: gooseai.TransformMatrix world_to_view_matrix = 1;
     */
    worldToViewMatrix?: TransformMatrix; // 4x4 transform matrix for the next frame
    /**
     * @generated from protobuf field: gooseai.CameraParameters camera_parameters = 2;
     */
    cameraParameters?: CameraParameters;
    /**
     * @generated from protobuf field: bool do_prefill = 5;
     */
    doPrefill: boolean; // Prefill masked areas with values matching the colors around the area
    /**
     * @generated from protobuf field: gooseai.RenderMode render_mode = 8;
     */
    renderMode: RenderMode; // Both image and mask will be rendered using this method.
}
/**
 * @generated from protobuf message gooseai.TransformParameters
 */
export interface TransformParameters {
    /**
     * @generated from protobuf oneof: transform
     */
    transform: {
        oneofKind: "colorAdjust";
        /**
         * @generated from protobuf field: gooseai.TransformColorAdjust color_adjust = 2;
         */
        colorAdjust: TransformColorAdjust;
    } | {
        oneofKind: "depthCalc";
        /**
         * @generated from protobuf field: gooseai.TransformDepthCalc depth_calc = 4;
         */
        depthCalc: TransformDepthCalc;
    } | {
        oneofKind: "resample";
        /**
         * @generated from protobuf field: gooseai.TransformResample resample = 5;
         */
        resample: TransformResample;
    } | {
        oneofKind: "cameraPose";
        /**
         * @generated from protobuf field: gooseai.TransformCameraPose camera_pose = 6;
         */
        cameraPose: TransformCameraPose;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gooseai.AssetParameters
 */
export interface AssetParameters {
    /**
     * @generated from protobuf field: gooseai.AssetAction action = 1;
     */
    action: AssetAction;
    /**
     * @generated from protobuf field: string project_id = 2;
     */
    projectId: string;
    /**
     * @generated from protobuf field: gooseai.AssetUse use = 3;
     */
    use: AssetUse;
}
/**
 * AnswerMeta is a set of metadata about an answer, usually the operating
 * environment.
 *
 * @generated from protobuf message gooseai.AnswerMeta
 */
export interface AnswerMeta {
    /**
     * @generated from protobuf field: optional string gpu_id = 1;
     */
    gpuId?: string;
    /**
     * @generated from protobuf field: optional string cpu_id = 2;
     */
    cpuId?: string;
    /**
     * @generated from protobuf field: optional string node_id = 3;
     */
    nodeId?: string;
    /**
     * @generated from protobuf field: optional string engine_id = 4;
     */
    engineId?: string;
}
/**
 * An Answer is a response to a Request. It is a set of Artifacts, which can be
 * of any type and forwarded to the client or the next stage.
 *
 * @generated from protobuf message gooseai.Answer
 */
export interface Answer {
    /**
     * @generated from protobuf field: string answer_id = 1;
     */
    answerId: string;
    /**
     * @generated from protobuf field: string request_id = 2;
     */
    requestId: string;
    /**
     * @generated from protobuf field: uint64 received = 3;
     */
    received: bigint;
    /**
     * @generated from protobuf field: uint64 created = 4;
     */
    created: bigint;
    /**
     * @generated from protobuf field: optional gooseai.AnswerMeta meta = 6;
     */
    meta?: AnswerMeta;
    /**
     * @generated from protobuf field: repeated gooseai.Artifact artifacts = 7;
     */
    artifacts: Artifact[];
}
/**
 * An AnswerBatch is a set of Answers. It can represent one or several completed
 * requests, which may be sent to the client in a single response.
 *
 * @generated from protobuf message gooseai.AnswerBatch
 */
export interface AnswerBatch {
    /**
     * @generated from protobuf field: string batch_id = 1;
     */
    batchId: string;
    /**
     * @generated from protobuf field: repeated gooseai.Answer answers = 2;
     */
    answers: Answer[];
}
/**
 * A Request is a set of Artifacts, which can be of any type with model or
 * transform parameters. It is sent to the server, which will respond with an
 * Answer.
 *
 * @generated from protobuf message gooseai.Request
 */
export interface Request {
    /**
     * @generated from protobuf field: string engine_id = 1;
     */
    engineId: string;
    /**
     * @generated from protobuf field: string request_id = 2;
     */
    requestId: string;
    /**
     * @generated from protobuf field: gooseai.ArtifactType requested_type = 3;
     */
    requestedType: ArtifactType;
    /**
     * @generated from protobuf field: repeated gooseai.Prompt prompt = 4;
     */
    prompt: Prompt[];
    /**
     * @generated from protobuf oneof: params
     */
    params: {
        oneofKind: "image";
        /**
         * @generated from protobuf field: gooseai.ImageParameters image = 5;
         */
        image: ImageParameters;
    } | {
        oneofKind: "classifier";
        /**
         * @generated from protobuf field: gooseai.ClassifierParameters classifier = 7;
         */
        classifier: ClassifierParameters;
    } | {
        oneofKind: "asset";
        /**
         * @generated from protobuf field: gooseai.AssetParameters asset = 8;
         */
        asset: AssetParameters;
    } | {
        oneofKind: "interpolate";
        /**
         * @generated from protobuf field: gooseai.InterpolateParameters interpolate = 11;
         */
        interpolate: InterpolateParameters;
    } | {
        oneofKind: "transform";
        /**
         * @generated from protobuf field: gooseai.TransformParameters transform = 12;
         */
        transform: TransformParameters;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: optional gooseai.ConditionerParameters conditioner = 6;
     */
    conditioner?: ConditionerParameters;
    /**
     * @generated from protobuf field: optional google.protobuf.Struct extras = 2047;
     */
    extras?: Struct; // for development use
}
/**
 * @generated from protobuf message gooseai.OnStatus
 */
export interface OnStatus {
    /**
     * @generated from protobuf field: repeated gooseai.FinishReason reason = 1;
     */
    reason: FinishReason[];
    /**
     * @generated from protobuf field: optional string target = 2;
     */
    target?: string;
    /**
     * @generated from protobuf field: repeated gooseai.StageAction action = 3;
     */
    action: StageAction[];
}
/**
 * @generated from protobuf message gooseai.Stage
 */
export interface Stage {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: gooseai.Request request = 2;
     */
    request?: Request;
    /**
     * @generated from protobuf field: repeated gooseai.OnStatus on_status = 3;
     */
    onStatus: OnStatus[];
}
/**
 * @generated from protobuf message gooseai.ChainRequest
 */
export interface ChainRequest {
    /**
     * @generated from protobuf field: string request_id = 1;
     */
    requestId: string;
    /**
     * @generated from protobuf field: repeated gooseai.Stage stage = 2;
     */
    stage: Stage[];
}
/**
 * @generated from protobuf enum gooseai.FinishReason
 */
export enum FinishReason {
    /**
     * @generated from protobuf enum value: NULL = 0;
     */
    NULL = 0,
    /**
     * @generated from protobuf enum value: LENGTH = 1;
     */
    LENGTH = 1,
    /**
     * @generated from protobuf enum value: STOP = 2;
     */
    STOP = 2,
    /**
     * @generated from protobuf enum value: ERROR = 3;
     */
    ERROR = 3,
    /**
     * @generated from protobuf enum value: FILTER = 4;
     */
    FILTER = 4
}
/**
 * @generated from protobuf enum gooseai.ArtifactType
 */
export enum ArtifactType {
    /**
     * @generated from protobuf enum value: ARTIFACT_NONE = 0;
     */
    ARTIFACT_NONE = 0,
    /**
     * @generated from protobuf enum value: ARTIFACT_IMAGE = 1;
     */
    ARTIFACT_IMAGE = 1,
    /**
     * @generated from protobuf enum value: ARTIFACT_VIDEO = 2;
     */
    ARTIFACT_VIDEO = 2,
    /**
     * @generated from protobuf enum value: ARTIFACT_TEXT = 3;
     */
    ARTIFACT_TEXT = 3,
    /**
     * @generated from protobuf enum value: ARTIFACT_TOKENS = 4;
     */
    ARTIFACT_TOKENS = 4,
    /**
     * @generated from protobuf enum value: ARTIFACT_EMBEDDING = 5;
     */
    ARTIFACT_EMBEDDING = 5,
    /**
     * @generated from protobuf enum value: ARTIFACT_CLASSIFICATIONS = 6;
     */
    ARTIFACT_CLASSIFICATIONS = 6,
    /**
     * @generated from protobuf enum value: ARTIFACT_MASK = 7;
     */
    ARTIFACT_MASK = 7,
    /**
     * @generated from protobuf enum value: ARTIFACT_LATENT = 8;
     */
    ARTIFACT_LATENT = 8,
    /**
     * @generated from protobuf enum value: ARTIFACT_TENSOR = 9;
     */
    ARTIFACT_TENSOR = 9,
    /**
     * @generated from protobuf enum value: ARTIFACT_DEPTH = 10;
     */
    ARTIFACT_DEPTH = 10
}
/**
 * @generated from protobuf enum gooseai.MaskedAreaInit
 */
export enum MaskedAreaInit {
    /**
     * @generated from protobuf enum value: MASKED_AREA_INIT_ZERO = 0;
     */
    ZERO = 0,
    /**
     * @generated from protobuf enum value: MASKED_AREA_INIT_RANDOM = 1;
     */
    RANDOM = 1,
    /**
     * @generated from protobuf enum value: MASKED_AREA_INIT_ORIGINAL = 2;
     */
    ORIGINAL = 2
}
/**
 * @generated from protobuf enum gooseai.WeightMethod
 */
export enum WeightMethod {
    /**
     * @generated from protobuf enum value: TEXT_ENCODER = 0;
     */
    TEXT_ENCODER = 0,
    /**
     * @generated from protobuf enum value: CROSS_ATTENTION = 1;
     */
    CROSS_ATTENTION = 1
}
/**
 * DiffusionSampler identifies which sampler to use for Diffusion, and represents
 * the internal set of supported samplers.
 *
 * @generated from protobuf enum gooseai.DiffusionSampler
 */
export enum DiffusionSampler {
    /**
     * @generated from protobuf enum value: SAMPLER_DDIM = 0;
     */
    SAMPLER_DDIM = 0,
    /**
     * @generated from protobuf enum value: SAMPLER_DDPM = 1;
     */
    SAMPLER_DDPM = 1,
    /**
     * @generated from protobuf enum value: SAMPLER_K_EULER = 2;
     */
    SAMPLER_K_EULER = 2,
    /**
     * @generated from protobuf enum value: SAMPLER_K_EULER_ANCESTRAL = 3;
     */
    SAMPLER_K_EULER_ANCESTRAL = 3,
    /**
     * @generated from protobuf enum value: SAMPLER_K_HEUN = 4;
     */
    SAMPLER_K_HEUN = 4,
    /**
     * @generated from protobuf enum value: SAMPLER_K_DPM_2 = 5;
     */
    SAMPLER_K_DPM_2 = 5,
    /**
     * @generated from protobuf enum value: SAMPLER_K_DPM_2_ANCESTRAL = 6;
     */
    SAMPLER_K_DPM_2_ANCESTRAL = 6,
    /**
     * @generated from protobuf enum value: SAMPLER_K_LMS = 7;
     */
    SAMPLER_K_LMS = 7,
    /**
     * @generated from protobuf enum value: SAMPLER_K_DPMPP_2S_ANCESTRAL = 8;
     */
    SAMPLER_K_DPMPP_2S_ANCESTRAL = 8,
    /**
     * @generated from protobuf enum value: SAMPLER_K_DPMPP_2M = 9;
     */
    SAMPLER_K_DPMPP_2M = 9,
    /**
     * @generated from protobuf enum value: SAMPLER_K_DPMPP_SDE = 10;
     */
    SAMPLER_K_DPMPP_SDE = 10
}
/**
 * Future, unimplemented.
 *
 * @generated from protobuf enum gooseai.Upscaler
 */
export enum Upscaler {
    /**
     * @generated from protobuf enum value: UPSCALER_RGB = 0;
     */
    RGB = 0,
    /**
     * @generated from protobuf enum value: UPSCALER_GFPGAN = 1;
     */
    GFPGAN = 1,
    /**
     * @generated from protobuf enum value: UPSCALER_ESRGAN = 2;
     */
    ESRGAN = 2
}
/**
 * Presets for CLIP guidance.
 *
 * @generated from protobuf enum gooseai.GuidancePreset
 */
export enum GuidancePreset {
    /**
     * @generated from protobuf enum value: GUIDANCE_PRESET_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: GUIDANCE_PRESET_SIMPLE = 1;
     */
    SIMPLE = 1,
    /**
     * @generated from protobuf enum value: GUIDANCE_PRESET_FAST_BLUE = 2;
     */
    FAST_BLUE = 2,
    /**
     * @generated from protobuf enum value: GUIDANCE_PRESET_FAST_GREEN = 3;
     */
    FAST_GREEN = 3,
    /**
     * @generated from protobuf enum value: GUIDANCE_PRESET_SLOW = 4;
     */
    SLOW = 4,
    /**
     * @generated from protobuf enum value: GUIDANCE_PRESET_SLOWER = 5;
     */
    SLOWER = 5,
    /**
     * @generated from protobuf enum value: GUIDANCE_PRESET_SLOWEST = 6;
     */
    SLOWEST = 6
}
/**
 * @generated from protobuf enum gooseai.ModelArchitecture
 */
export enum ModelArchitecture {
    /**
     * @generated from protobuf enum value: MODEL_ARCHITECTURE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: MODEL_ARCHITECTURE_CLIP_VIT = 1;
     */
    CLIP_VIT = 1,
    /**
     * @generated from protobuf enum value: MODEL_ARCHITECTURE_CLIP_RESNET = 2;
     */
    CLIP_RESNET = 2,
    /**
     * @generated from protobuf enum value: MODEL_ARCHITECTURE_LDM = 3;
     */
    LDM = 3
}
/**
 * @generated from protobuf enum gooseai.Action
 */
export enum Action {
    /**
     * @generated from protobuf enum value: ACTION_PASSTHROUGH = 0;
     */
    PASSTHROUGH = 0,
    /**
     * @generated from protobuf enum value: ACTION_REGENERATE_DUPLICATE = 1;
     */
    REGENERATE_DUPLICATE = 1,
    /**
     * @generated from protobuf enum value: ACTION_REGENERATE = 2;
     */
    REGENERATE = 2,
    /**
     * @generated from protobuf enum value: ACTION_OBFUSCATE_DUPLICATE = 3;
     */
    OBFUSCATE_DUPLICATE = 3,
    /**
     * @generated from protobuf enum value: ACTION_OBFUSCATE = 4;
     */
    OBFUSCATE = 4,
    /**
     * @generated from protobuf enum value: ACTION_DISCARD = 5;
     */
    DISCARD = 5
}
// 
// Artifact classification parameters.
// 

/**
 * @generated from protobuf enum gooseai.ClassifierMode
 */
export enum ClassifierMode {
    /**
     * @generated from protobuf enum value: CLSFR_MODE_ZEROSHOT = 0;
     */
    CLSFR_MODE_ZEROSHOT = 0,
    /**
     * CLSFR_MODE_ODDSRATIO = 2;
     *
     * @generated from protobuf enum value: CLSFR_MODE_MULTICLASS = 1;
     */
    CLSFR_MODE_MULTICLASS = 1
}
// 
// Interpolation
// 

/**
 * @generated from protobuf enum gooseai.InterpolateMode
 */
export enum InterpolateMode {
    /**
     * @generated from protobuf enum value: INTERPOLATE_LINEAR = 0;
     */
    INTERPOLATE_LINEAR = 0,
    /**
     * @generated from protobuf enum value: INTERPOLATE_RIFE = 1;
     */
    INTERPOLATE_RIFE = 1,
    /**
     * @generated from protobuf enum value: INTERPOLATE_VAE_LINEAR = 2;
     */
    INTERPOLATE_VAE_LINEAR = 2,
    /**
     * @generated from protobuf enum value: INTERPOLATE_VAE_SLERP = 3;
     */
    INTERPOLATE_VAE_SLERP = 3,
    /**
     * @generated from protobuf enum value: INTERPOLATE_FILM = 4;
     */
    INTERPOLATE_FILM = 4
}
// 
// Transforms
// 

/**
 * @generated from protobuf enum gooseai.BorderMode
 */
export enum BorderMode {
    /**
     * reflect image values across the border
     *
     * @generated from protobuf enum value: BORDER_REFLECT = 0;
     */
    BORDER_REFLECT = 0,
    /**
     * replicate border values outside the image
     *
     * @generated from protobuf enum value: BORDER_REPLICATE = 1;
     */
    BORDER_REPLICATE = 1,
    /**
     * wrap around / tile the image values
     *
     * @generated from protobuf enum value: BORDER_WRAP = 2;
     */
    BORDER_WRAP = 2,
    /**
     * use 0 for locations outside the image
     *
     * @generated from protobuf enum value: BORDER_ZERO = 3;
     */
    BORDER_ZERO = 3,
    /**
     * prefill border areas with values matching the colors around the area
     *
     * @generated from protobuf enum value: BORDER_PREFILL = 4;
     */
    BORDER_PREFILL = 4
}
/**
 * @generated from protobuf enum gooseai.ColorMatchMode
 */
export enum ColorMatchMode {
    /**
     * match hue, saturation, and value histograms
     *
     * @generated from protobuf enum value: COLOR_MATCH_HSV = 0;
     */
    COLOR_MATCH_HSV = 0,
    /**
     * match lightness, a, and b histograms
     *
     * @generated from protobuf enum value: COLOR_MATCH_LAB = 1;
     */
    COLOR_MATCH_LAB = 1,
    /**
     * match red, green, and blue histograms
     *
     * @generated from protobuf enum value: COLOR_MATCH_RGB = 2;
     */
    COLOR_MATCH_RGB = 2
}
/**
 * @generated from protobuf enum gooseai.CameraType
 */
export enum CameraType {
    /**
     * Perspective camera
     *
     * @generated from protobuf enum value: CAMERA_PERSPECTIVE = 0;
     */
    CAMERA_PERSPECTIVE = 0,
    /**
     * Orthographic camera. Well suited for isometric animations
     *
     * @generated from protobuf enum value: CAMERA_ORTHOGRAPHIC = 1;
     */
    CAMERA_ORTHOGRAPHIC = 1
}
/**
 * @generated from protobuf enum gooseai.RenderMode
 */
export enum RenderMode {
    /**
     * @generated from protobuf enum value: RENDER_MESH = 0;
     */
    RENDER_MESH = 0,
    /**
     * @generated from protobuf enum value: RENDER_POINTCLOUD = 1;
     */
    RENDER_POINTCLOUD = 1
}
// 
// Asset parameters
// 

/**
 * @generated from protobuf enum gooseai.AssetAction
 */
export enum AssetAction {
    /**
     * @generated from protobuf enum value: ASSET_PUT = 0;
     */
    ASSET_PUT = 0,
    /**
     * @generated from protobuf enum value: ASSET_GET = 1;
     */
    ASSET_GET = 1,
    /**
     * @generated from protobuf enum value: ASSET_DELETE = 2;
     */
    ASSET_DELETE = 2
}
/**
 * AssetUse defines how the asset is used within a project.  This enum matches
 * the values the project proto.
 *
 * @generated from protobuf enum gooseai.AssetUse
 */
export enum AssetUse {
    /**
     * Asset does not have use defined
     *
     * @generated from protobuf enum value: ASSET_USE_UNDEFINED = 0;
     */
    UNDEFINED = 0,
    /**
     * Asset is used as an input for the project
     *
     * @generated from protobuf enum value: ASSET_USE_INPUT = 1;
     */
    INPUT = 1,
    /**
     * Asset is an output from the project
     *
     * @generated from protobuf enum value: ASSET_USE_OUTPUT = 2;
     */
    OUTPUT = 2,
    /**
     * Asset is an output from an intermediate step of the project
     *
     * @generated from protobuf enum value: ASSET_USE_INTERMEDIATE = 3;
     */
    INTERMEDIATE = 3,
    /**
     * Asset is used as the project file for the project
     *
     * @generated from protobuf enum value: ASSET_USE_PROJECT = 4;
     */
    PROJECT = 4
}
// 
// Stages
// 
// A Stage is a single step in a pipeline. Stages are a set of Requests, which are
// sent to the server, and a set of Answers, which are received from the server.

/**
 * @generated from protobuf enum gooseai.StageAction
 */
export enum StageAction {
    /**
     * @generated from protobuf enum value: STAGE_ACTION_PASS = 0;
     */
    PASS = 0,
    /**
     * @generated from protobuf enum value: STAGE_ACTION_DISCARD = 1;
     */
    DISCARD = 1,
    /**
     * @generated from protobuf enum value: STAGE_ACTION_RETURN = 2;
     */
    RETURN = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Token$Type extends MessageType<Token> {
    constructor() {
        super("gooseai.Token", [
            { no: 1, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Token>): Token {
        const message = { id: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Token>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token): Token {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string text */ 1:
                    message.text = reader.string();
                    break;
                case /* uint32 id */ 2:
                    message.id = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string text = 1; */
        if (message.text !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* uint32 id = 2; */
        if (message.id !== 0)
            writer.tag(2, WireType.Varint).uint32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Token
 */
export const Token = new Token$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tokens$Type extends MessageType<Tokens> {
    constructor() {
        super("gooseai.Tokens", [
            { no: 1, name: "tokens", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Token },
            { no: 2, name: "tokenizer_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Tokens>): Tokens {
        const message = { tokens: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tokens>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tokens): Tokens {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseai.Token tokens */ 1:
                    message.tokens.push(Token.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string tokenizer_id */ 2:
                    message.tokenizerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tokens, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseai.Token tokens = 1; */
        for (let i = 0; i < message.tokens.length; i++)
            Token.internalBinaryWrite(message.tokens[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string tokenizer_id = 2; */
        if (message.tokenizerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.tokenizerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Tokens
 */
export const Tokens = new Tokens$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Artifact$Type extends MessageType<Artifact> {
    constructor() {
        super("gooseai.Artifact", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["gooseai.ArtifactType", ArtifactType] },
            { no: 3, name: "mime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "magic", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "binary", kind: "scalar", oneof: "data", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "text", kind: "scalar", oneof: "data", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "tokens", kind: "message", oneof: "data", T: () => Tokens },
            { no: 11, name: "classifier", kind: "message", oneof: "data", T: () => ClassifierParameters },
            { no: 14, name: "tensor", kind: "message", oneof: "data", T: () => Tensor },
            { no: 8, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "finish_reason", kind: "enum", T: () => ["gooseai.FinishReason", FinishReason] },
            { no: 10, name: "seed", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Artifact>): Artifact {
        const message = { id: 0n, type: 0, mime: "", data: { oneofKind: undefined }, index: 0, finishReason: 0, seed: 0, uuid: "", size: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Artifact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Artifact): Artifact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* gooseai.ArtifactType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string mime */ 3:
                    message.mime = reader.string();
                    break;
                case /* optional string magic */ 4:
                    message.magic = reader.string();
                    break;
                case /* bytes binary */ 5:
                    message.data = {
                        oneofKind: "binary",
                        binary: reader.bytes()
                    };
                    break;
                case /* string text */ 6:
                    message.data = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* gooseai.Tokens tokens */ 7:
                    message.data = {
                        oneofKind: "tokens",
                        tokens: Tokens.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).tokens)
                    };
                    break;
                case /* gooseai.ClassifierParameters classifier */ 11:
                    message.data = {
                        oneofKind: "classifier",
                        classifier: ClassifierParameters.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).classifier)
                    };
                    break;
                case /* tensors.Tensor tensor */ 14:
                    message.data = {
                        oneofKind: "tensor",
                        tensor: Tensor.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).tensor)
                    };
                    break;
                case /* uint32 index */ 8:
                    message.index = reader.uint32();
                    break;
                case /* gooseai.FinishReason finish_reason */ 9:
                    message.finishReason = reader.int32();
                    break;
                case /* uint32 seed */ 10:
                    message.seed = reader.uint32();
                    break;
                case /* string uuid */ 12:
                    message.uuid = reader.string();
                    break;
                case /* uint64 size */ 13:
                    message.size = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Artifact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* gooseai.ArtifactType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string mime = 3; */
        if (message.mime !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.mime);
        /* optional string magic = 4; */
        if (message.magic !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.magic);
        /* bytes binary = 5; */
        if (message.data.oneofKind === "binary")
            writer.tag(5, WireType.LengthDelimited).bytes(message.data.binary);
        /* string text = 6; */
        if (message.data.oneofKind === "text")
            writer.tag(6, WireType.LengthDelimited).string(message.data.text);
        /* gooseai.Tokens tokens = 7; */
        if (message.data.oneofKind === "tokens")
            Tokens.internalBinaryWrite(message.data.tokens, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.ClassifierParameters classifier = 11; */
        if (message.data.oneofKind === "classifier")
            ClassifierParameters.internalBinaryWrite(message.data.classifier, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tensors.Tensor tensor = 14; */
        if (message.data.oneofKind === "tensor")
            Tensor.internalBinaryWrite(message.data.tensor, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint32 index = 8; */
        if (message.index !== 0)
            writer.tag(8, WireType.Varint).uint32(message.index);
        /* gooseai.FinishReason finish_reason = 9; */
        if (message.finishReason !== 0)
            writer.tag(9, WireType.Varint).int32(message.finishReason);
        /* uint32 seed = 10; */
        if (message.seed !== 0)
            writer.tag(10, WireType.Varint).uint32(message.seed);
        /* string uuid = 12; */
        if (message.uuid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.uuid);
        /* uint64 size = 13; */
        if (message.size !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Artifact
 */
export const Artifact = new Artifact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PromptParameters$Type extends MessageType<PromptParameters> {
    constructor() {
        super("gooseai.PromptParameters", [
            { no: 1, name: "init", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "weight", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PromptParameters>): PromptParameters {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PromptParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PromptParameters): PromptParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool init */ 1:
                    message.init = reader.bool();
                    break;
                case /* optional float weight */ 2:
                    message.weight = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PromptParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool init = 1; */
        if (message.init !== undefined)
            writer.tag(1, WireType.Varint).bool(message.init);
        /* optional float weight = 2; */
        if (message.weight !== undefined)
            writer.tag(2, WireType.Bit32).float(message.weight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.PromptParameters
 */
export const PromptParameters = new PromptParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Prompt$Type extends MessageType<Prompt> {
    constructor() {
        super("gooseai.Prompt", [
            { no: 1, name: "parameters", kind: "message", T: () => PromptParameters },
            { no: 2, name: "text", kind: "scalar", oneof: "prompt", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tokens", kind: "message", oneof: "prompt", T: () => Tokens },
            { no: 4, name: "artifact", kind: "message", oneof: "prompt", T: () => Artifact }
        ]);
    }
    create(value?: PartialMessage<Prompt>): Prompt {
        const message = { prompt: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Prompt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Prompt): Prompt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional gooseai.PromptParameters parameters */ 1:
                    message.parameters = PromptParameters.internalBinaryRead(reader, reader.uint32(), options, message.parameters);
                    break;
                case /* string text */ 2:
                    message.prompt = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* gooseai.Tokens tokens */ 3:
                    message.prompt = {
                        oneofKind: "tokens",
                        tokens: Tokens.internalBinaryRead(reader, reader.uint32(), options, (message.prompt as any).tokens)
                    };
                    break;
                case /* gooseai.Artifact artifact */ 4:
                    message.prompt = {
                        oneofKind: "artifact",
                        artifact: Artifact.internalBinaryRead(reader, reader.uint32(), options, (message.prompt as any).artifact)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Prompt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional gooseai.PromptParameters parameters = 1; */
        if (message.parameters)
            PromptParameters.internalBinaryWrite(message.parameters, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string text = 2; */
        if (message.prompt.oneofKind === "text")
            writer.tag(2, WireType.LengthDelimited).string(message.prompt.text);
        /* gooseai.Tokens tokens = 3; */
        if (message.prompt.oneofKind === "tokens")
            Tokens.internalBinaryWrite(message.prompt.tokens, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.Artifact artifact = 4; */
        if (message.prompt.oneofKind === "artifact")
            Artifact.internalBinaryWrite(message.prompt.artifact, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Prompt
 */
export const Prompt = new Prompt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SamplerParameters$Type extends MessageType<SamplerParameters> {
    constructor() {
        super("gooseai.SamplerParameters", [
            { no: 1, name: "eta", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "sampling_steps", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "latent_channels", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "downsampling_factor", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "cfg_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "init_noise_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "step_noise_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<SamplerParameters>): SamplerParameters {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SamplerParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SamplerParameters): SamplerParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float eta */ 1:
                    message.eta = reader.float();
                    break;
                case /* optional uint64 sampling_steps */ 2:
                    message.samplingSteps = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 latent_channels */ 3:
                    message.latentChannels = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 downsampling_factor */ 4:
                    message.downsamplingFactor = reader.uint64().toBigInt();
                    break;
                case /* optional float cfg_scale */ 5:
                    message.cfgScale = reader.float();
                    break;
                case /* optional float init_noise_scale */ 6:
                    message.initNoiseScale = reader.float();
                    break;
                case /* optional float step_noise_scale */ 7:
                    message.stepNoiseScale = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SamplerParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float eta = 1; */
        if (message.eta !== undefined)
            writer.tag(1, WireType.Bit32).float(message.eta);
        /* optional uint64 sampling_steps = 2; */
        if (message.samplingSteps !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.samplingSteps);
        /* optional uint64 latent_channels = 3; */
        if (message.latentChannels !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.latentChannels);
        /* optional uint64 downsampling_factor = 4; */
        if (message.downsamplingFactor !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.downsamplingFactor);
        /* optional float cfg_scale = 5; */
        if (message.cfgScale !== undefined)
            writer.tag(5, WireType.Bit32).float(message.cfgScale);
        /* optional float init_noise_scale = 6; */
        if (message.initNoiseScale !== undefined)
            writer.tag(6, WireType.Bit32).float(message.initNoiseScale);
        /* optional float step_noise_scale = 7; */
        if (message.stepNoiseScale !== undefined)
            writer.tag(7, WireType.Bit32).float(message.stepNoiseScale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.SamplerParameters
 */
export const SamplerParameters = new SamplerParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConditionerParameters$Type extends MessageType<ConditionerParameters> {
    constructor() {
        super("gooseai.ConditionerParameters", [
            { no: 1, name: "vector_adjust_prior", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "conditioner", kind: "message", T: () => Model }
        ]);
    }
    create(value?: PartialMessage<ConditionerParameters>): ConditionerParameters {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConditionerParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConditionerParameters): ConditionerParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string vector_adjust_prior */ 1:
                    message.vectorAdjustPrior = reader.string();
                    break;
                case /* optional gooseai.Model conditioner */ 2:
                    message.conditioner = Model.internalBinaryRead(reader, reader.uint32(), options, message.conditioner);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConditionerParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string vector_adjust_prior = 1; */
        if (message.vectorAdjustPrior !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.vectorAdjustPrior);
        /* optional gooseai.Model conditioner = 2; */
        if (message.conditioner)
            Model.internalBinaryWrite(message.conditioner, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ConditionerParameters
 */
export const ConditionerParameters = new ConditionerParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScheduleParameters$Type extends MessageType<ScheduleParameters> {
    constructor() {
        super("gooseai.ScheduleParameters", [
            { no: 1, name: "start", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "end", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ScheduleParameters>): ScheduleParameters {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScheduleParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScheduleParameters): ScheduleParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float start */ 1:
                    message.start = reader.float();
                    break;
                case /* optional float end */ 2:
                    message.end = reader.float();
                    break;
                case /* optional float value */ 3:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScheduleParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float start = 1; */
        if (message.start !== undefined)
            writer.tag(1, WireType.Bit32).float(message.start);
        /* optional float end = 2; */
        if (message.end !== undefined)
            writer.tag(2, WireType.Bit32).float(message.end);
        /* optional float value = 3; */
        if (message.value !== undefined)
            writer.tag(3, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ScheduleParameters
 */
export const ScheduleParameters = new ScheduleParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepParameter$Type extends MessageType<StepParameter> {
    constructor() {
        super("gooseai.StepParameter", [
            { no: 1, name: "scaled_step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "sampler", kind: "message", T: () => SamplerParameters },
            { no: 3, name: "schedule", kind: "message", T: () => ScheduleParameters },
            { no: 4, name: "guidance", kind: "message", T: () => GuidanceParameters }
        ]);
    }
    create(value?: PartialMessage<StepParameter>): StepParameter {
        const message = { scaledStep: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StepParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepParameter): StepParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float scaled_step */ 1:
                    message.scaledStep = reader.float();
                    break;
                case /* optional gooseai.SamplerParameters sampler */ 2:
                    message.sampler = SamplerParameters.internalBinaryRead(reader, reader.uint32(), options, message.sampler);
                    break;
                case /* optional gooseai.ScheduleParameters schedule */ 3:
                    message.schedule = ScheduleParameters.internalBinaryRead(reader, reader.uint32(), options, message.schedule);
                    break;
                case /* optional gooseai.GuidanceParameters guidance */ 4:
                    message.guidance = GuidanceParameters.internalBinaryRead(reader, reader.uint32(), options, message.guidance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float scaled_step = 1; */
        if (message.scaledStep !== 0)
            writer.tag(1, WireType.Bit32).float(message.scaledStep);
        /* optional gooseai.SamplerParameters sampler = 2; */
        if (message.sampler)
            SamplerParameters.internalBinaryWrite(message.sampler, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.ScheduleParameters schedule = 3; */
        if (message.schedule)
            ScheduleParameters.internalBinaryWrite(message.schedule, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.GuidanceParameters guidance = 4; */
        if (message.guidance)
            GuidanceParameters.internalBinaryWrite(message.guidance, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.StepParameter
 */
export const StepParameter = new StepParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Model$Type extends MessageType<Model> {
    constructor() {
        super("gooseai.Model", [
            { no: 1, name: "architecture", kind: "enum", T: () => ["gooseai.ModelArchitecture", ModelArchitecture, "MODEL_ARCHITECTURE_"] },
            { no: 2, name: "publisher", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dataset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "semantic_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "alias", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Model>): Model {
        const message = { architecture: 0, publisher: "", dataset: "", version: 0, semanticVersion: "", alias: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Model>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Model): Model {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.ModelArchitecture architecture */ 1:
                    message.architecture = reader.int32();
                    break;
                case /* string publisher */ 2:
                    message.publisher = reader.string();
                    break;
                case /* string dataset */ 3:
                    message.dataset = reader.string();
                    break;
                case /* float version */ 4:
                    message.version = reader.float();
                    break;
                case /* string semantic_version */ 5:
                    message.semanticVersion = reader.string();
                    break;
                case /* string alias */ 6:
                    message.alias = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Model, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.ModelArchitecture architecture = 1; */
        if (message.architecture !== 0)
            writer.tag(1, WireType.Varint).int32(message.architecture);
        /* string publisher = 2; */
        if (message.publisher !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.publisher);
        /* string dataset = 3; */
        if (message.dataset !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dataset);
        /* float version = 4; */
        if (message.version !== 0)
            writer.tag(4, WireType.Bit32).float(message.version);
        /* string semantic_version = 5; */
        if (message.semanticVersion !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.semanticVersion);
        /* string alias = 6; */
        if (message.alias !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.alias);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Model
 */
export const Model = new Model$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CutoutParameters$Type extends MessageType<CutoutParameters> {
    constructor() {
        super("gooseai.CutoutParameters", [
            { no: 1, name: "cutouts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CutoutParameters },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "gray", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "blur", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "size_power", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CutoutParameters>): CutoutParameters {
        const message = { cutouts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CutoutParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CutoutParameters): CutoutParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseai.CutoutParameters cutouts */ 1:
                    message.cutouts.push(CutoutParameters.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                case /* optional float gray */ 3:
                    message.gray = reader.float();
                    break;
                case /* optional float blur */ 4:
                    message.blur = reader.float();
                    break;
                case /* optional float size_power */ 5:
                    message.sizePower = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CutoutParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseai.CutoutParameters cutouts = 1; */
        for (let i = 0; i < message.cutouts.length; i++)
            CutoutParameters.internalBinaryWrite(message.cutouts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.count);
        /* optional float gray = 3; */
        if (message.gray !== undefined)
            writer.tag(3, WireType.Bit32).float(message.gray);
        /* optional float blur = 4; */
        if (message.blur !== undefined)
            writer.tag(4, WireType.Bit32).float(message.blur);
        /* optional float size_power = 5; */
        if (message.sizePower !== undefined)
            writer.tag(5, WireType.Bit32).float(message.sizePower);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.CutoutParameters
 */
export const CutoutParameters = new CutoutParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuidanceScheduleParameters$Type extends MessageType<GuidanceScheduleParameters> {
    constructor() {
        super("gooseai.GuidanceScheduleParameters", [
            { no: 1, name: "duration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<GuidanceScheduleParameters>): GuidanceScheduleParameters {
        const message = { duration: 0, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GuidanceScheduleParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuidanceScheduleParameters): GuidanceScheduleParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float duration */ 1:
                    message.duration = reader.float();
                    break;
                case /* float value */ 2:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuidanceScheduleParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float duration = 1; */
        if (message.duration !== 0)
            writer.tag(1, WireType.Bit32).float(message.duration);
        /* float value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.GuidanceScheduleParameters
 */
export const GuidanceScheduleParameters = new GuidanceScheduleParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuidanceInstanceParameters$Type extends MessageType<GuidanceInstanceParameters> {
    constructor() {
        super("gooseai.GuidanceInstanceParameters", [
            { no: 2, name: "models", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Model },
            { no: 3, name: "guidance_strength", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "schedule", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GuidanceScheduleParameters },
            { no: 5, name: "cutouts", kind: "message", T: () => CutoutParameters },
            { no: 6, name: "prompt", kind: "message", T: () => Prompt }
        ]);
    }
    create(value?: PartialMessage<GuidanceInstanceParameters>): GuidanceInstanceParameters {
        const message = { models: [], schedule: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GuidanceInstanceParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuidanceInstanceParameters): GuidanceInstanceParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseai.Model models */ 2:
                    message.models.push(Model.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float guidance_strength */ 3:
                    message.guidanceStrength = reader.float();
                    break;
                case /* repeated gooseai.GuidanceScheduleParameters schedule */ 4:
                    message.schedule.push(GuidanceScheduleParameters.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional gooseai.CutoutParameters cutouts */ 5:
                    message.cutouts = CutoutParameters.internalBinaryRead(reader, reader.uint32(), options, message.cutouts);
                    break;
                case /* optional gooseai.Prompt prompt */ 6:
                    message.prompt = Prompt.internalBinaryRead(reader, reader.uint32(), options, message.prompt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuidanceInstanceParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseai.Model models = 2; */
        for (let i = 0; i < message.models.length; i++)
            Model.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional float guidance_strength = 3; */
        if (message.guidanceStrength !== undefined)
            writer.tag(3, WireType.Bit32).float(message.guidanceStrength);
        /* repeated gooseai.GuidanceScheduleParameters schedule = 4; */
        for (let i = 0; i < message.schedule.length; i++)
            GuidanceScheduleParameters.internalBinaryWrite(message.schedule[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.CutoutParameters cutouts = 5; */
        if (message.cutouts)
            CutoutParameters.internalBinaryWrite(message.cutouts, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.Prompt prompt = 6; */
        if (message.prompt)
            Prompt.internalBinaryWrite(message.prompt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.GuidanceInstanceParameters
 */
export const GuidanceInstanceParameters = new GuidanceInstanceParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuidanceParameters$Type extends MessageType<GuidanceParameters> {
    constructor() {
        super("gooseai.GuidanceParameters", [
            { no: 1, name: "guidance_preset", kind: "enum", T: () => ["gooseai.GuidancePreset", GuidancePreset, "GUIDANCE_PRESET_"] },
            { no: 2, name: "instances", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GuidanceInstanceParameters }
        ]);
    }
    create(value?: PartialMessage<GuidanceParameters>): GuidanceParameters {
        const message = { guidancePreset: 0, instances: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GuidanceParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GuidanceParameters): GuidanceParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.GuidancePreset guidance_preset */ 1:
                    message.guidancePreset = reader.int32();
                    break;
                case /* repeated gooseai.GuidanceInstanceParameters instances */ 2:
                    message.instances.push(GuidanceInstanceParameters.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GuidanceParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.GuidancePreset guidance_preset = 1; */
        if (message.guidancePreset !== 0)
            writer.tag(1, WireType.Varint).int32(message.guidancePreset);
        /* repeated gooseai.GuidanceInstanceParameters instances = 2; */
        for (let i = 0; i < message.instances.length; i++)
            GuidanceInstanceParameters.internalBinaryWrite(message.instances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.GuidanceParameters
 */
export const GuidanceParameters = new GuidanceParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformType$Type extends MessageType<TransformType> {
    constructor() {
        super("gooseai.TransformType", [
            { no: 1, name: "diffusion", kind: "enum", oneof: "type", T: () => ["gooseai.DiffusionSampler", DiffusionSampler] },
            { no: 2, name: "upscaler", kind: "enum", oneof: "type", T: () => ["gooseai.Upscaler", Upscaler, "UPSCALER_"] }
        ]);
    }
    create(value?: PartialMessage<TransformType>): TransformType {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransformType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransformType): TransformType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.DiffusionSampler diffusion */ 1:
                    message.type = {
                        oneofKind: "diffusion",
                        diffusion: reader.int32()
                    };
                    break;
                case /* gooseai.Upscaler upscaler */ 2:
                    message.type = {
                        oneofKind: "upscaler",
                        upscaler: reader.int32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransformType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.DiffusionSampler diffusion = 1; */
        if (message.type.oneofKind === "diffusion")
            writer.tag(1, WireType.Varint).int32(message.type.diffusion);
        /* gooseai.Upscaler upscaler = 2; */
        if (message.type.oneofKind === "upscaler")
            writer.tag(2, WireType.Varint).int32(message.type.upscaler);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TransformType
 */
export const TransformType = new TransformType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageParameters$Type extends MessageType<ImageParameters> {
    constructor() {
        super("gooseai.ImageParameters", [
            { no: 1, name: "height", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "width", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "seed", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "samples", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "steps", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "transform", kind: "message", T: () => TransformType },
            { no: 7, name: "parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StepParameter },
            { no: 8, name: "masked_area_init", kind: "enum", opt: true, T: () => ["gooseai.MaskedAreaInit", MaskedAreaInit, "MASKED_AREA_INIT_"] },
            { no: 9, name: "weight_method", kind: "enum", opt: true, T: () => ["gooseai.WeightMethod", WeightMethod] },
            { no: 10, name: "quantize", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ImageParameters>): ImageParameters {
        const message = { seed: [], parameters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImageParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageParameters): ImageParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 height */ 1:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 width */ 2:
                    message.width = reader.uint64().toBigInt();
                    break;
                case /* repeated uint32 seed */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.seed.push(reader.uint32());
                    else
                        message.seed.push(reader.uint32());
                    break;
                case /* optional uint64 samples */ 4:
                    message.samples = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 steps */ 5:
                    message.steps = reader.uint64().toBigInt();
                    break;
                case /* optional gooseai.TransformType transform */ 6:
                    message.transform = TransformType.internalBinaryRead(reader, reader.uint32(), options, message.transform);
                    break;
                case /* repeated gooseai.StepParameter parameters */ 7:
                    message.parameters.push(StepParameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional gooseai.MaskedAreaInit masked_area_init */ 8:
                    message.maskedAreaInit = reader.int32();
                    break;
                case /* optional gooseai.WeightMethod weight_method */ 9:
                    message.weightMethod = reader.int32();
                    break;
                case /* optional bool quantize */ 10:
                    message.quantize = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 height = 1; */
        if (message.height !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* optional uint64 width = 2; */
        if (message.width !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.width);
        /* repeated uint32 seed = 3; */
        if (message.seed.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.seed.length; i++)
                writer.uint32(message.seed[i]);
            writer.join();
        }
        /* optional uint64 samples = 4; */
        if (message.samples !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.samples);
        /* optional uint64 steps = 5; */
        if (message.steps !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.steps);
        /* optional gooseai.TransformType transform = 6; */
        if (message.transform)
            TransformType.internalBinaryWrite(message.transform, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated gooseai.StepParameter parameters = 7; */
        for (let i = 0; i < message.parameters.length; i++)
            StepParameter.internalBinaryWrite(message.parameters[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.MaskedAreaInit masked_area_init = 8; */
        if (message.maskedAreaInit !== undefined)
            writer.tag(8, WireType.Varint).int32(message.maskedAreaInit);
        /* optional gooseai.WeightMethod weight_method = 9; */
        if (message.weightMethod !== undefined)
            writer.tag(9, WireType.Varint).int32(message.weightMethod);
        /* optional bool quantize = 10; */
        if (message.quantize !== undefined)
            writer.tag(10, WireType.Varint).bool(message.quantize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ImageParameters
 */
export const ImageParameters = new ImageParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassifierConcept$Type extends MessageType<ClassifierConcept> {
    constructor() {
        super("gooseai.ClassifierConcept", [
            { no: 1, name: "concept", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "threshold", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ClassifierConcept>): ClassifierConcept {
        const message = { concept: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClassifierConcept>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassifierConcept): ClassifierConcept {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string concept */ 1:
                    message.concept = reader.string();
                    break;
                case /* optional float threshold */ 2:
                    message.threshold = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassifierConcept, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string concept = 1; */
        if (message.concept !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.concept);
        /* optional float threshold = 2; */
        if (message.threshold !== undefined)
            writer.tag(2, WireType.Bit32).float(message.threshold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ClassifierConcept
 */
export const ClassifierConcept = new ClassifierConcept$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassifierCategory$Type extends MessageType<ClassifierCategory> {
    constructor() {
        super("gooseai.ClassifierCategory", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "concepts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClassifierConcept },
            { no: 3, name: "adjustment", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "action", kind: "enum", opt: true, T: () => ["gooseai.Action", Action, "ACTION_"] },
            { no: 5, name: "classifier_mode", kind: "enum", opt: true, T: () => ["gooseai.ClassifierMode", ClassifierMode] }
        ]);
    }
    create(value?: PartialMessage<ClassifierCategory>): ClassifierCategory {
        const message = { name: "", concepts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClassifierCategory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassifierCategory): ClassifierCategory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated gooseai.ClassifierConcept concepts */ 2:
                    message.concepts.push(ClassifierConcept.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float adjustment */ 3:
                    message.adjustment = reader.float();
                    break;
                case /* optional gooseai.Action action */ 4:
                    message.action = reader.int32();
                    break;
                case /* optional gooseai.ClassifierMode classifier_mode */ 5:
                    message.classifierMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassifierCategory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated gooseai.ClassifierConcept concepts = 2; */
        for (let i = 0; i < message.concepts.length; i++)
            ClassifierConcept.internalBinaryWrite(message.concepts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional float adjustment = 3; */
        if (message.adjustment !== undefined)
            writer.tag(3, WireType.Bit32).float(message.adjustment);
        /* optional gooseai.Action action = 4; */
        if (message.action !== undefined)
            writer.tag(4, WireType.Varint).int32(message.action);
        /* optional gooseai.ClassifierMode classifier_mode = 5; */
        if (message.classifierMode !== undefined)
            writer.tag(5, WireType.Varint).int32(message.classifierMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ClassifierCategory
 */
export const ClassifierCategory = new ClassifierCategory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassifierParameters$Type extends MessageType<ClassifierParameters> {
    constructor() {
        super("gooseai.ClassifierParameters", [
            { no: 1, name: "categories", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClassifierCategory },
            { no: 2, name: "exceeds", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClassifierCategory },
            { no: 3, name: "realized_action", kind: "enum", opt: true, T: () => ["gooseai.Action", Action, "ACTION_"] }
        ]);
    }
    create(value?: PartialMessage<ClassifierParameters>): ClassifierParameters {
        const message = { categories: [], exceeds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClassifierParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassifierParameters): ClassifierParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseai.ClassifierCategory categories */ 1:
                    message.categories.push(ClassifierCategory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated gooseai.ClassifierCategory exceeds */ 2:
                    message.exceeds.push(ClassifierCategory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional gooseai.Action realized_action */ 3:
                    message.realizedAction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassifierParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseai.ClassifierCategory categories = 1; */
        for (let i = 0; i < message.categories.length; i++)
            ClassifierCategory.internalBinaryWrite(message.categories[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated gooseai.ClassifierCategory exceeds = 2; */
        for (let i = 0; i < message.exceeds.length; i++)
            ClassifierCategory.internalBinaryWrite(message.exceeds[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.Action realized_action = 3; */
        if (message.realizedAction !== undefined)
            writer.tag(3, WireType.Varint).int32(message.realizedAction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ClassifierParameters
 */
export const ClassifierParameters = new ClassifierParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterpolateParameters$Type extends MessageType<InterpolateParameters> {
    constructor() {
        super("gooseai.InterpolateParameters", [
            { no: 1, name: "ratios", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "mode", kind: "enum", opt: true, T: () => ["gooseai.InterpolateMode", InterpolateMode] }
        ]);
    }
    create(value?: PartialMessage<InterpolateParameters>): InterpolateParameters {
        const message = { ratios: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InterpolateParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterpolateParameters): InterpolateParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float ratios */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ratios.push(reader.float());
                    else
                        message.ratios.push(reader.float());
                    break;
                case /* optional gooseai.InterpolateMode mode */ 2:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterpolateParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float ratios = 1; */
        if (message.ratios.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ratios.length; i++)
                writer.float(message.ratios[i]);
            writer.join();
        }
        /* optional gooseai.InterpolateMode mode = 2; */
        if (message.mode !== undefined)
            writer.tag(2, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.InterpolateParameters
 */
export const InterpolateParameters = new InterpolateParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformColorAdjust$Type extends MessageType<TransformColorAdjust> {
    constructor() {
        super("gooseai.TransformColorAdjust", [
            { no: 1, name: "brightness", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "contrast", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "hue", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "saturation", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "lightness", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "match_image", kind: "message", T: () => Artifact },
            { no: 7, name: "match_mode", kind: "enum", opt: true, T: () => ["gooseai.ColorMatchMode", ColorMatchMode] },
            { no: 8, name: "noise_amount", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "noise_seed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TransformColorAdjust>): TransformColorAdjust {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransformColorAdjust>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransformColorAdjust): TransformColorAdjust {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float brightness */ 1:
                    message.brightness = reader.float();
                    break;
                case /* optional float contrast */ 2:
                    message.contrast = reader.float();
                    break;
                case /* optional float hue */ 3:
                    message.hue = reader.float();
                    break;
                case /* optional float saturation */ 4:
                    message.saturation = reader.float();
                    break;
                case /* optional float lightness */ 5:
                    message.lightness = reader.float();
                    break;
                case /* optional gooseai.Artifact match_image */ 6:
                    message.matchImage = Artifact.internalBinaryRead(reader, reader.uint32(), options, message.matchImage);
                    break;
                case /* optional gooseai.ColorMatchMode match_mode */ 7:
                    message.matchMode = reader.int32();
                    break;
                case /* optional float noise_amount */ 8:
                    message.noiseAmount = reader.float();
                    break;
                case /* optional uint32 noise_seed */ 9:
                    message.noiseSeed = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransformColorAdjust, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float brightness = 1; */
        if (message.brightness !== undefined)
            writer.tag(1, WireType.Bit32).float(message.brightness);
        /* optional float contrast = 2; */
        if (message.contrast !== undefined)
            writer.tag(2, WireType.Bit32).float(message.contrast);
        /* optional float hue = 3; */
        if (message.hue !== undefined)
            writer.tag(3, WireType.Bit32).float(message.hue);
        /* optional float saturation = 4; */
        if (message.saturation !== undefined)
            writer.tag(4, WireType.Bit32).float(message.saturation);
        /* optional float lightness = 5; */
        if (message.lightness !== undefined)
            writer.tag(5, WireType.Bit32).float(message.lightness);
        /* optional gooseai.Artifact match_image = 6; */
        if (message.matchImage)
            Artifact.internalBinaryWrite(message.matchImage, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.ColorMatchMode match_mode = 7; */
        if (message.matchMode !== undefined)
            writer.tag(7, WireType.Varint).int32(message.matchMode);
        /* optional float noise_amount = 8; */
        if (message.noiseAmount !== undefined)
            writer.tag(8, WireType.Bit32).float(message.noiseAmount);
        /* optional uint32 noise_seed = 9; */
        if (message.noiseSeed !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.noiseSeed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TransformColorAdjust
 */
export const TransformColorAdjust = new TransformColorAdjust$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformDepthCalc$Type extends MessageType<TransformDepthCalc> {
    constructor() {
        super("gooseai.TransformDepthCalc", [
            { no: 1, name: "blend_weight", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "blur_radius", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "reverse", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TransformDepthCalc>): TransformDepthCalc {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransformDepthCalc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransformDepthCalc): TransformDepthCalc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float blend_weight */ 1:
                    message.blendWeight = reader.float();
                    break;
                case /* optional uint32 blur_radius */ 2:
                    message.blurRadius = reader.uint32();
                    break;
                case /* optional bool reverse */ 3:
                    message.reverse = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransformDepthCalc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float blend_weight = 1; */
        if (message.blendWeight !== undefined)
            writer.tag(1, WireType.Bit32).float(message.blendWeight);
        /* optional uint32 blur_radius = 2; */
        if (message.blurRadius !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.blurRadius);
        /* optional bool reverse = 3; */
        if (message.reverse !== undefined)
            writer.tag(3, WireType.Varint).bool(message.reverse);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TransformDepthCalc
 */
export const TransformDepthCalc = new TransformDepthCalc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformMatrix$Type extends MessageType<TransformMatrix> {
    constructor() {
        super("gooseai.TransformMatrix", [
            { no: 1, name: "data", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<TransformMatrix>): TransformMatrix {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransformMatrix>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransformMatrix): TransformMatrix {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float data = 1 [packed = true];*/ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.data.push(reader.float());
                    else
                        message.data.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransformMatrix, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float data = 1 [packed = true]; */
        if (message.data.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.data.length; i++)
                writer.float(message.data[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TransformMatrix
 */
export const TransformMatrix = new TransformMatrix$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformResample$Type extends MessageType<TransformResample> {
    constructor() {
        super("gooseai.TransformResample", [
            { no: 1, name: "border_mode", kind: "enum", T: () => ["gooseai.BorderMode", BorderMode] },
            { no: 2, name: "transform", kind: "message", T: () => TransformMatrix },
            { no: 3, name: "prev_transform", kind: "message", T: () => TransformMatrix },
            { no: 4, name: "depth_warp", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "export_mask", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TransformResample>): TransformResample {
        const message = { borderMode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransformResample>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransformResample): TransformResample {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.BorderMode border_mode */ 1:
                    message.borderMode = reader.int32();
                    break;
                case /* gooseai.TransformMatrix transform */ 2:
                    message.transform = TransformMatrix.internalBinaryRead(reader, reader.uint32(), options, message.transform);
                    break;
                case /* optional gooseai.TransformMatrix prev_transform */ 3:
                    message.prevTransform = TransformMatrix.internalBinaryRead(reader, reader.uint32(), options, message.prevTransform);
                    break;
                case /* optional float depth_warp */ 4:
                    message.depthWarp = reader.float();
                    break;
                case /* optional bool export_mask */ 5:
                    message.exportMask = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransformResample, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.BorderMode border_mode = 1; */
        if (message.borderMode !== 0)
            writer.tag(1, WireType.Varint).int32(message.borderMode);
        /* gooseai.TransformMatrix transform = 2; */
        if (message.transform)
            TransformMatrix.internalBinaryWrite(message.transform, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.TransformMatrix prev_transform = 3; */
        if (message.prevTransform)
            TransformMatrix.internalBinaryWrite(message.prevTransform, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional float depth_warp = 4; */
        if (message.depthWarp !== undefined)
            writer.tag(4, WireType.Bit32).float(message.depthWarp);
        /* optional bool export_mask = 5; */
        if (message.exportMask !== undefined)
            writer.tag(5, WireType.Varint).bool(message.exportMask);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TransformResample
 */
export const TransformResample = new TransformResample$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraParameters$Type extends MessageType<CameraParameters> {
    constructor() {
        super("gooseai.CameraParameters", [
            { no: 1, name: "camera_type", kind: "enum", T: () => ["gooseai.CameraType", CameraType] },
            { no: 2, name: "near_plane", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "far_plane", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "fov", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CameraParameters>): CameraParameters {
        const message = { cameraType: 0, nearPlane: 0, farPlane: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CameraParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraParameters): CameraParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.CameraType camera_type */ 1:
                    message.cameraType = reader.int32();
                    break;
                case /* float near_plane */ 2:
                    message.nearPlane = reader.float();
                    break;
                case /* float far_plane */ 3:
                    message.farPlane = reader.float();
                    break;
                case /* optional float fov */ 4:
                    message.fov = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.CameraType camera_type = 1; */
        if (message.cameraType !== 0)
            writer.tag(1, WireType.Varint).int32(message.cameraType);
        /* float near_plane = 2; */
        if (message.nearPlane !== 0)
            writer.tag(2, WireType.Bit32).float(message.nearPlane);
        /* float far_plane = 3; */
        if (message.farPlane !== 0)
            writer.tag(3, WireType.Bit32).float(message.farPlane);
        /* optional float fov = 4; */
        if (message.fov !== undefined)
            writer.tag(4, WireType.Bit32).float(message.fov);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.CameraParameters
 */
export const CameraParameters = new CameraParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformCameraPose$Type extends MessageType<TransformCameraPose> {
    constructor() {
        super("gooseai.TransformCameraPose", [
            { no: 1, name: "world_to_view_matrix", kind: "message", T: () => TransformMatrix },
            { no: 2, name: "camera_parameters", kind: "message", T: () => CameraParameters },
            { no: 5, name: "do_prefill", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "render_mode", kind: "enum", T: () => ["gooseai.RenderMode", RenderMode] }
        ]);
    }
    create(value?: PartialMessage<TransformCameraPose>): TransformCameraPose {
        const message = { doPrefill: false, renderMode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransformCameraPose>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransformCameraPose): TransformCameraPose {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.TransformMatrix world_to_view_matrix */ 1:
                    message.worldToViewMatrix = TransformMatrix.internalBinaryRead(reader, reader.uint32(), options, message.worldToViewMatrix);
                    break;
                case /* gooseai.CameraParameters camera_parameters */ 2:
                    message.cameraParameters = CameraParameters.internalBinaryRead(reader, reader.uint32(), options, message.cameraParameters);
                    break;
                case /* bool do_prefill */ 5:
                    message.doPrefill = reader.bool();
                    break;
                case /* gooseai.RenderMode render_mode */ 8:
                    message.renderMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransformCameraPose, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.TransformMatrix world_to_view_matrix = 1; */
        if (message.worldToViewMatrix)
            TransformMatrix.internalBinaryWrite(message.worldToViewMatrix, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.CameraParameters camera_parameters = 2; */
        if (message.cameraParameters)
            CameraParameters.internalBinaryWrite(message.cameraParameters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool do_prefill = 5; */
        if (message.doPrefill !== false)
            writer.tag(5, WireType.Varint).bool(message.doPrefill);
        /* gooseai.RenderMode render_mode = 8; */
        if (message.renderMode !== 0)
            writer.tag(8, WireType.Varint).int32(message.renderMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TransformCameraPose
 */
export const TransformCameraPose = new TransformCameraPose$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformParameters$Type extends MessageType<TransformParameters> {
    constructor() {
        super("gooseai.TransformParameters", [
            { no: 2, name: "color_adjust", kind: "message", oneof: "transform", T: () => TransformColorAdjust },
            { no: 4, name: "depth_calc", kind: "message", oneof: "transform", T: () => TransformDepthCalc },
            { no: 5, name: "resample", kind: "message", oneof: "transform", T: () => TransformResample },
            { no: 6, name: "camera_pose", kind: "message", oneof: "transform", T: () => TransformCameraPose }
        ]);
    }
    create(value?: PartialMessage<TransformParameters>): TransformParameters {
        const message = { transform: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransformParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransformParameters): TransformParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.TransformColorAdjust color_adjust */ 2:
                    message.transform = {
                        oneofKind: "colorAdjust",
                        colorAdjust: TransformColorAdjust.internalBinaryRead(reader, reader.uint32(), options, (message.transform as any).colorAdjust)
                    };
                    break;
                case /* gooseai.TransformDepthCalc depth_calc */ 4:
                    message.transform = {
                        oneofKind: "depthCalc",
                        depthCalc: TransformDepthCalc.internalBinaryRead(reader, reader.uint32(), options, (message.transform as any).depthCalc)
                    };
                    break;
                case /* gooseai.TransformResample resample */ 5:
                    message.transform = {
                        oneofKind: "resample",
                        resample: TransformResample.internalBinaryRead(reader, reader.uint32(), options, (message.transform as any).resample)
                    };
                    break;
                case /* gooseai.TransformCameraPose camera_pose */ 6:
                    message.transform = {
                        oneofKind: "cameraPose",
                        cameraPose: TransformCameraPose.internalBinaryRead(reader, reader.uint32(), options, (message.transform as any).cameraPose)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransformParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.TransformColorAdjust color_adjust = 2; */
        if (message.transform.oneofKind === "colorAdjust")
            TransformColorAdjust.internalBinaryWrite(message.transform.colorAdjust, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.TransformDepthCalc depth_calc = 4; */
        if (message.transform.oneofKind === "depthCalc")
            TransformDepthCalc.internalBinaryWrite(message.transform.depthCalc, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.TransformResample resample = 5; */
        if (message.transform.oneofKind === "resample")
            TransformResample.internalBinaryWrite(message.transform.resample, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.TransformCameraPose camera_pose = 6; */
        if (message.transform.oneofKind === "cameraPose")
            TransformCameraPose.internalBinaryWrite(message.transform.cameraPose, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TransformParameters
 */
export const TransformParameters = new TransformParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetParameters$Type extends MessageType<AssetParameters> {
    constructor() {
        super("gooseai.AssetParameters", [
            { no: 1, name: "action", kind: "enum", T: () => ["gooseai.AssetAction", AssetAction] },
            { no: 2, name: "project_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "use", kind: "enum", T: () => ["gooseai.AssetUse", AssetUse, "ASSET_USE_"] }
        ]);
    }
    create(value?: PartialMessage<AssetParameters>): AssetParameters {
        const message = { action: 0, projectId: "", use: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetParameters): AssetParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseai.AssetAction action */ 1:
                    message.action = reader.int32();
                    break;
                case /* string project_id */ 2:
                    message.projectId = reader.string();
                    break;
                case /* gooseai.AssetUse use */ 3:
                    message.use = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseai.AssetAction action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* string project_id = 2; */
        if (message.projectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.projectId);
        /* gooseai.AssetUse use = 3; */
        if (message.use !== 0)
            writer.tag(3, WireType.Varint).int32(message.use);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.AssetParameters
 */
export const AssetParameters = new AssetParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnswerMeta$Type extends MessageType<AnswerMeta> {
    constructor() {
        super("gooseai.AnswerMeta", [
            { no: 1, name: "gpu_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cpu_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "node_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "engine_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AnswerMeta>): AnswerMeta {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnswerMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnswerMeta): AnswerMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string gpu_id */ 1:
                    message.gpuId = reader.string();
                    break;
                case /* optional string cpu_id */ 2:
                    message.cpuId = reader.string();
                    break;
                case /* optional string node_id */ 3:
                    message.nodeId = reader.string();
                    break;
                case /* optional string engine_id */ 4:
                    message.engineId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnswerMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string gpu_id = 1; */
        if (message.gpuId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.gpuId);
        /* optional string cpu_id = 2; */
        if (message.cpuId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.cpuId);
        /* optional string node_id = 3; */
        if (message.nodeId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.nodeId);
        /* optional string engine_id = 4; */
        if (message.engineId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.engineId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.AnswerMeta
 */
export const AnswerMeta = new AnswerMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Answer$Type extends MessageType<Answer> {
    constructor() {
        super("gooseai.Answer", [
            { no: 1, name: "answer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "received", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "created", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "meta", kind: "message", T: () => AnswerMeta },
            { no: 7, name: "artifacts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Artifact }
        ]);
    }
    create(value?: PartialMessage<Answer>): Answer {
        const message = { answerId: "", requestId: "", received: 0n, created: 0n, artifacts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Answer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Answer): Answer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string answer_id */ 1:
                    message.answerId = reader.string();
                    break;
                case /* string request_id */ 2:
                    message.requestId = reader.string();
                    break;
                case /* uint64 received */ 3:
                    message.received = reader.uint64().toBigInt();
                    break;
                case /* uint64 created */ 4:
                    message.created = reader.uint64().toBigInt();
                    break;
                case /* optional gooseai.AnswerMeta meta */ 6:
                    message.meta = AnswerMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* repeated gooseai.Artifact artifacts */ 7:
                    message.artifacts.push(Artifact.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Answer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string answer_id = 1; */
        if (message.answerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.answerId);
        /* string request_id = 2; */
        if (message.requestId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.requestId);
        /* uint64 received = 3; */
        if (message.received !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.received);
        /* uint64 created = 4; */
        if (message.created !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.created);
        /* optional gooseai.AnswerMeta meta = 6; */
        if (message.meta)
            AnswerMeta.internalBinaryWrite(message.meta, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated gooseai.Artifact artifacts = 7; */
        for (let i = 0; i < message.artifacts.length; i++)
            Artifact.internalBinaryWrite(message.artifacts[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Answer
 */
export const Answer = new Answer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnswerBatch$Type extends MessageType<AnswerBatch> {
    constructor() {
        super("gooseai.AnswerBatch", [
            { no: 1, name: "batch_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "answers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Answer }
        ]);
    }
    create(value?: PartialMessage<AnswerBatch>): AnswerBatch {
        const message = { batchId: "", answers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AnswerBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnswerBatch): AnswerBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string batch_id */ 1:
                    message.batchId = reader.string();
                    break;
                case /* repeated gooseai.Answer answers */ 2:
                    message.answers.push(Answer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnswerBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string batch_id = 1; */
        if (message.batchId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.batchId);
        /* repeated gooseai.Answer answers = 2; */
        for (let i = 0; i < message.answers.length; i++)
            Answer.internalBinaryWrite(message.answers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.AnswerBatch
 */
export const AnswerBatch = new AnswerBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Request$Type extends MessageType<Request> {
    constructor() {
        super("gooseai.Request", [
            { no: 1, name: "engine_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "requested_type", kind: "enum", T: () => ["gooseai.ArtifactType", ArtifactType] },
            { no: 4, name: "prompt", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Prompt },
            { no: 5, name: "image", kind: "message", oneof: "params", T: () => ImageParameters },
            { no: 7, name: "classifier", kind: "message", oneof: "params", T: () => ClassifierParameters },
            { no: 8, name: "asset", kind: "message", oneof: "params", T: () => AssetParameters },
            { no: 11, name: "interpolate", kind: "message", oneof: "params", T: () => InterpolateParameters },
            { no: 12, name: "transform", kind: "message", oneof: "params", T: () => TransformParameters },
            { no: 6, name: "conditioner", kind: "message", T: () => ConditionerParameters },
            { no: 2047, name: "extras", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Request>): Request {
        const message = { engineId: "", requestId: "", requestedType: 0, prompt: [], params: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Request): Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string engine_id */ 1:
                    message.engineId = reader.string();
                    break;
                case /* string request_id */ 2:
                    message.requestId = reader.string();
                    break;
                case /* gooseai.ArtifactType requested_type */ 3:
                    message.requestedType = reader.int32();
                    break;
                case /* repeated gooseai.Prompt prompt */ 4:
                    message.prompt.push(Prompt.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* gooseai.ImageParameters image */ 5:
                    message.params = {
                        oneofKind: "image",
                        image: ImageParameters.internalBinaryRead(reader, reader.uint32(), options, (message.params as any).image)
                    };
                    break;
                case /* gooseai.ClassifierParameters classifier */ 7:
                    message.params = {
                        oneofKind: "classifier",
                        classifier: ClassifierParameters.internalBinaryRead(reader, reader.uint32(), options, (message.params as any).classifier)
                    };
                    break;
                case /* gooseai.AssetParameters asset */ 8:
                    message.params = {
                        oneofKind: "asset",
                        asset: AssetParameters.internalBinaryRead(reader, reader.uint32(), options, (message.params as any).asset)
                    };
                    break;
                case /* gooseai.InterpolateParameters interpolate */ 11:
                    message.params = {
                        oneofKind: "interpolate",
                        interpolate: InterpolateParameters.internalBinaryRead(reader, reader.uint32(), options, (message.params as any).interpolate)
                    };
                    break;
                case /* gooseai.TransformParameters transform */ 12:
                    message.params = {
                        oneofKind: "transform",
                        transform: TransformParameters.internalBinaryRead(reader, reader.uint32(), options, (message.params as any).transform)
                    };
                    break;
                case /* optional gooseai.ConditionerParameters conditioner */ 6:
                    message.conditioner = ConditionerParameters.internalBinaryRead(reader, reader.uint32(), options, message.conditioner);
                    break;
                case /* optional google.protobuf.Struct extras */ 2047:
                    message.extras = Struct.internalBinaryRead(reader, reader.uint32(), options, message.extras);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string engine_id = 1; */
        if (message.engineId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.engineId);
        /* string request_id = 2; */
        if (message.requestId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.requestId);
        /* gooseai.ArtifactType requested_type = 3; */
        if (message.requestedType !== 0)
            writer.tag(3, WireType.Varint).int32(message.requestedType);
        /* repeated gooseai.Prompt prompt = 4; */
        for (let i = 0; i < message.prompt.length; i++)
            Prompt.internalBinaryWrite(message.prompt[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.ImageParameters image = 5; */
        if (message.params.oneofKind === "image")
            ImageParameters.internalBinaryWrite(message.params.image, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.ClassifierParameters classifier = 7; */
        if (message.params.oneofKind === "classifier")
            ClassifierParameters.internalBinaryWrite(message.params.classifier, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.AssetParameters asset = 8; */
        if (message.params.oneofKind === "asset")
            AssetParameters.internalBinaryWrite(message.params.asset, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.InterpolateParameters interpolate = 11; */
        if (message.params.oneofKind === "interpolate")
            InterpolateParameters.internalBinaryWrite(message.params.interpolate, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* gooseai.TransformParameters transform = 12; */
        if (message.params.oneofKind === "transform")
            TransformParameters.internalBinaryWrite(message.params.transform, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional gooseai.ConditionerParameters conditioner = 6; */
        if (message.conditioner)
            ConditionerParameters.internalBinaryWrite(message.conditioner, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Struct extras = 2047; */
        if (message.extras)
            Struct.internalBinaryWrite(message.extras, writer.tag(2047, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Request
 */
export const Request = new Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OnStatus$Type extends MessageType<OnStatus> {
    constructor() {
        super("gooseai.OnStatus", [
            { no: 1, name: "reason", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["gooseai.FinishReason", FinishReason] },
            { no: 2, name: "target", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "action", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["gooseai.StageAction", StageAction, "STAGE_ACTION_"] }
        ]);
    }
    create(value?: PartialMessage<OnStatus>): OnStatus {
        const message = { reason: [], action: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OnStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OnStatus): OnStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseai.FinishReason reason */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.reason.push(reader.int32());
                    else
                        message.reason.push(reader.int32());
                    break;
                case /* optional string target */ 2:
                    message.target = reader.string();
                    break;
                case /* repeated gooseai.StageAction action */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.action.push(reader.int32());
                    else
                        message.action.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OnStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseai.FinishReason reason = 1; */
        if (message.reason.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.reason.length; i++)
                writer.int32(message.reason[i]);
            writer.join();
        }
        /* optional string target = 2; */
        if (message.target !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.target);
        /* repeated gooseai.StageAction action = 3; */
        if (message.action.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.action.length; i++)
                writer.int32(message.action[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.OnStatus
 */
export const OnStatus = new OnStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stage$Type extends MessageType<Stage> {
    constructor() {
        super("gooseai.Stage", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => Request },
            { no: 3, name: "on_status", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OnStatus }
        ]);
    }
    create(value?: PartialMessage<Stage>): Stage {
        const message = { id: "", onStatus: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Stage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stage): Stage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* gooseai.Request request */ 2:
                    message.request = Request.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* repeated gooseai.OnStatus on_status */ 3:
                    message.onStatus.push(OnStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* gooseai.Request request = 2; */
        if (message.request)
            Request.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated gooseai.OnStatus on_status = 3; */
        for (let i = 0; i < message.onStatus.length; i++)
            OnStatus.internalBinaryWrite(message.onStatus[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Stage
 */
export const Stage = new Stage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChainRequest$Type extends MessageType<ChainRequest> {
    constructor() {
        super("gooseai.ChainRequest", [
            { no: 1, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "stage", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Stage }
        ]);
    }
    create(value?: PartialMessage<ChainRequest>): ChainRequest {
        const message = { requestId: "", stage: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChainRequest): ChainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.requestId = reader.string();
                    break;
                case /* repeated gooseai.Stage stage */ 2:
                    message.stage.push(Stage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string request_id = 1; */
        if (message.requestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.requestId);
        /* repeated gooseai.Stage stage = 2; */
        for (let i = 0; i < message.stage.length; i++)
            Stage.internalBinaryWrite(message.stage[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ChainRequest
 */
export const ChainRequest = new ChainRequest$Type();
/**
 * @generated ServiceType for protobuf service gooseai.GenerationService
 */
export const GenerationService = new ServiceType("gooseai.GenerationService", [
    { name: "Generate", serverStreaming: true, options: {}, I: Request, O: Answer },
    { name: "ChainGenerate", serverStreaming: true, options: {}, I: ChainRequest, O: Answer }
]);
