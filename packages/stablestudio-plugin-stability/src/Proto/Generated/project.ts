// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "project.proto" (package "gooseai", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Request } from "./generation";
/**
 * @generated from protobuf message gooseai.ProjectAsset
 */
export interface ProjectAsset {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the asset, UUIDv4
    /**
     * @generated from protobuf field: string uri = 2;
     */
    uri: string; // The URI to the asset
    /**
     * @generated from protobuf field: gooseai.ProjectAssetUse use = 3;
     */
    use: ProjectAssetUse; // The use of the asset with respect to the project
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string; // The name of the asset
    /**
     * @generated from protobuf field: uint64 size = 5;
     */
    size: bigint; // The asset size in bytes
    /**
     * @generated from protobuf field: uint64 created_at = 6;
     */
    createdAt: bigint; // Time of asset creation (UTC seconds epoch)
    /**
     * @generated from protobuf field: uint64 updated_at = 7;
     */
    updatedAt: bigint; // Time of last asset update (UTC seconds epoch)
    /**
     * @generated from protobuf field: gooseai.Request request = 8;
     */
    request?: Request; // The request object that is associated with the artifact
    /**
     * @generated from protobuf field: map<string, string> tags = 9;
     */
    tags: {
        [key: string]: string;
    }; // The tags associated with the asset
}
/**
 * @generated from protobuf message gooseai.Project
 */
export interface Project {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project, UUIDv4
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string; // Title of the project
    /**
     * @generated from protobuf field: string owner_id = 3;
     */
    ownerId: string; // The ID of the organization owning the project
    /**
     * @generated from protobuf field: gooseai.ProjectAccess access = 4;
     */
    access: ProjectAccess; // The access of the project (such as public vs private)
    /**
     * @generated from protobuf field: gooseai.ProjectStatus status = 5;
     */
    status: ProjectStatus; // The status of the project (such as active vs inactive)
    /**
     * @generated from protobuf field: uint64 size = 6;
     */
    size: bigint; // The size of the project in bytes
    /**
     * @generated from protobuf field: gooseai.ProjectAsset file = 7;
     */
    file?: ProjectAsset; // Project file for the project
    /**
     * @generated from protobuf field: uint64 created_at = 8;
     */
    createdAt: bigint; // Time of project creation (UTC seconds epoch)
    /**
     * @generated from protobuf field: uint64 updated_at = 9;
     */
    updatedAt: bigint; // Time of last project update (UTC seconds epoch)
    /**
     * @generated from protobuf field: repeated gooseai.ProjectAsset assets = 10;
     */
    assets: ProjectAsset[]; // The listing of all assets associated with the project
}
/**
 * @generated from protobuf message gooseai.CreateProjectRequest
 */
export interface CreateProjectRequest {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string; // title of the project
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the project, empty for default org for user
    /**
     * @generated from protobuf field: gooseai.ProjectAccess access = 3;
     */
    access: ProjectAccess; // The access of the project (such as public vs private)
    /**
     * @generated from protobuf field: gooseai.ProjectStatus status = 4;
     */
    status: ProjectStatus; // The status of the project (such as active vs inactive)
    /**
     * @generated from protobuf field: optional gooseai.ProjectAsset file = 5;
     */
    file?: ProjectAsset; // Project file for the project (if existing, else will create)
}
/**
 * @generated from protobuf message gooseai.UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project, UUIDv4
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the project, empty for default org for user
    /**
     * @generated from protobuf field: optional string title = 3;
     */
    title?: string; // Title of the project
    /**
     * @generated from protobuf field: optional gooseai.ProjectAccess access = 4;
     */
    access?: ProjectAccess; // The access of the project (such as public vs private)
    /**
     * @generated from protobuf field: optional gooseai.ProjectStatus status = 5;
     */
    status?: ProjectStatus; // The status of the project (such as active vs inactive)
    /**
     * @generated from protobuf field: optional gooseai.ProjectAsset file = 6;
     */
    file?: ProjectAsset; // Project file for the project
}
/**
 * @generated from protobuf message gooseai.ListProjectRequest
 */
export interface ListProjectRequest {
    /**
     * @generated from protobuf field: optional string owner_id = 1;
     */
    ownerId?: string; // The ID of the organization owning the project, empty for default org for user
}
/**
 * @generated from protobuf message gooseai.GetProjectRequest
 */
export interface GetProjectRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project to request, UUIDv4, empty string uses default project
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the project, empty for default org for user
}
/**
 * @generated from protobuf message gooseai.DeleteProjectRequest
 */
export interface DeleteProjectRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project to request, UUIDv4
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the project, empty for default org for user
}
/**
 * @generated from protobuf message gooseai.QueryAssetsRequest
 */
export interface QueryAssetsRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project to request, UUIDv4, empty string uses default project
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the assets, unset for default org for user
    /**
     * @generated from protobuf field: optional uint64 since = 3;
     */
    since?: bigint; // The time (UTC seconds epoch) to start listing assets from, unset for no restriction
    /**
     * @generated from protobuf field: optional uint64 until = 4;
     */
    until?: bigint; // The time (UTC seconds epoch) to stop listing assets at, unset for no restriction
    /**
     * @generated from protobuf field: optional uint64 limit = 5;
     */
    limit?: bigint; // The maximum number of assets to return, unset for no limit
    /**
     * @generated from protobuf field: optional string start_key = 6;
     */
    startKey?: string; // The key to start from, used to paginate results, unset for no offset
    /**
     * @generated from protobuf field: repeated gooseai.ProjectAssetUse use = 7;
     */
    use: ProjectAssetUse[]; // The asset usage to filter the assets returned, empty for no filter
    /**
     * @generated from protobuf field: gooseai.ProjectSortDir sort_dir = 8;
     */
    sortDir: ProjectSortDir; // The sort direction based on asset creation time, default is descending
    /**
     * @generated from protobuf field: map<string, string> tags = 9;
     */
    tags: {
        [key: string]: string;
    }; // The tag values used to filter the assets returned, empty for no filter
}
/**
 * @generated from protobuf message gooseai.QueryAssetsResponse
 */
export interface QueryAssetsResponse {
    /**
     * @generated from protobuf field: repeated gooseai.ProjectAsset assets = 1;
     */
    assets: ProjectAsset[]; // The assets returned by the query
    /**
     * @generated from protobuf field: optional string last_key = 2;
     */
    lastKey?: string; // The last asset key returned when the results were limited, unset when not limited
}
/**
 * @generated from protobuf message gooseai.TagAssetsRequest
 */
export interface TagAssetsRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project to request, UUIDv4, empty string uses default project
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the assets, unset for default org for user
    /**
     * @generated from protobuf field: repeated string asset_ids = 3;
     */
    assetIds: string[]; // The IDs of the assets to tag in the project, UUIDv4, limit 1000
    /**
     * @generated from protobuf field: map<string, string> tags = 4;
     */
    tags: {
        [key: string]: string;
    }; // The tags to add to the assets
}
/**
 * @generated from protobuf message gooseai.TagAssetsResponse
 */
export interface TagAssetsResponse {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project, UUIDv4
    /**
     * @generated from protobuf field: string owner_id = 2;
     */
    ownerId: string; // The ID of the organization owning the project
    /**
     * @generated from protobuf field: repeated string asset_ids = 3;
     */
    assetIds: string[]; // The IDs of the assets updated in the project, UUIDv4, limit 1000
}
/**
 * @generated from protobuf message gooseai.UntagAssetsRequest
 */
export interface UntagAssetsRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project to request, UUIDv4, empty string uses default project
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the assets, unset for default org for user
    /**
     * @generated from protobuf field: repeated string asset_ids = 3;
     */
    assetIds: string[]; // The IDs of the assets to tag in the project, UUIDv4, limit 1000
    /**
     * @generated from protobuf field: repeated string tag_keys = 4;
     */
    tagKeys: string[]; // The keys of the tags to remove from the assets
}
/**
 * @generated from protobuf message gooseai.UntagAssetsResponse
 */
export interface UntagAssetsResponse {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project, UUIDv4
    /**
     * @generated from protobuf field: string owner_id = 2;
     */
    ownerId: string; // The ID of the organization owning the project
    /**
     * @generated from protobuf field: repeated string asset_ids = 3;
     */
    assetIds: string[]; // The IDs of the assets updated in the project, UUIDv4, limit 1000
}
/**
 * @generated from protobuf message gooseai.DeleteAssetsRequest
 */
export interface DeleteAssetsRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project to request, UUIDv4, empty string uses default project
    /**
     * @generated from protobuf field: optional string owner_id = 2;
     */
    ownerId?: string; // The ID of the organization owning the project, unset for default org for user
    /**
     * @generated from protobuf field: repeated string asset_ids = 3;
     */
    assetIds: string[]; // The IDs of the assets to delete from the project, UUIDv4, limit 1000
}
/**
 * @generated from protobuf message gooseai.DeleteAssetsResponse
 */
export interface DeleteAssetsResponse {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // ID of the project, UUIDv4
    /**
     * @generated from protobuf field: string owner_id = 2;
     */
    ownerId: string; // The ID of the organization owning the project
    /**
     * @generated from protobuf field: repeated string asset_ids = 3;
     */
    assetIds: string[]; // The IDs of the assets deleted from the project, UUIDv4, limit 1000
}
/**
 * @generated from protobuf enum gooseai.ProjectAccess
 */
export enum ProjectAccess {
    /**
     * Private access, only owner organization can access
     *
     * @generated from protobuf enum value: PROJECT_ACCESS_PRIVATE = 0;
     */
    PRIVATE = 0,
    /**
     * Public access, anyone can access
     *
     * @generated from protobuf enum value: PROJECT_ACCESS_PUBLIC = 1;
     */
    PUBLIC = 1
}
/**
 * @generated from protobuf enum gooseai.ProjectStatus
 */
export enum ProjectStatus {
    /**
     * Inactive project
     *
     * @generated from protobuf enum value: PROJECT_STATUS_INACTIVE = 0;
     */
    INACTIVE = 0,
    /**
     * Active project
     *
     * @generated from protobuf enum value: PROJECT_STATUS_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * Deleted project, only set by delete endpoint
     *
     * @generated from protobuf enum value: PROJECT_STATUS_DELETED = 2;
     */
    DELETED = 2
}
/**
 * @generated from protobuf enum gooseai.ProjectAssetUse
 */
export enum ProjectAssetUse {
    /**
     * Asset does not have use defined
     *
     * @generated from protobuf enum value: PROJECT_ASSET_USE_UNDEFINED = 0;
     */
    UNDEFINED = 0,
    /**
     * Asset is used as an input for the project
     *
     * @generated from protobuf enum value: PROJECT_ASSET_USE_INPUT = 1;
     */
    INPUT = 1,
    /**
     * Asset is an output from the project
     *
     * @generated from protobuf enum value: PROJECT_ASSET_USE_OUTPUT = 2;
     */
    OUTPUT = 2,
    /**
     * Asset is an output from an intermediate step of the project
     *
     * @generated from protobuf enum value: PROJECT_ASSET_USE_INTERMEDIATE = 3;
     */
    INTERMEDIATE = 3,
    /**
     * Asset is used as the project file for the project
     *
     * @generated from protobuf enum value: PROJECT_ASSET_USE_PROJECT = 4;
     */
    PROJECT = 4
}
/**
 * @generated from protobuf enum gooseai.ProjectSortDir
 */
export enum ProjectSortDir {
    /**
     * Sort direction is not specified, uses default
     *
     * @generated from protobuf enum value: PROJECT_SORT_DIR_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Sort in ascending order
     *
     * @generated from protobuf enum value: PROJECT_SORT_DIR_ASC = 1;
     */
    ASC = 1,
    /**
     * Sort in descending order
     *
     * @generated from protobuf enum value: PROJECT_SORT_DIR_DESC = 2;
     */
    DESC = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ProjectAsset$Type extends MessageType<ProjectAsset> {
    constructor() {
        super("gooseai.ProjectAsset", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "use", kind: "enum", T: () => ["gooseai.ProjectAssetUse", ProjectAssetUse, "PROJECT_ASSET_USE_"] },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "created_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "updated_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "request", kind: "message", T: () => Request },
            { no: 9, name: "tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ProjectAsset>): ProjectAsset {
        const message = { id: "", uri: "", use: 0, name: "", size: 0n, createdAt: 0n, updatedAt: 0n, tags: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProjectAsset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProjectAsset): ProjectAsset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string uri */ 2:
                    message.uri = reader.string();
                    break;
                case /* gooseai.ProjectAssetUse use */ 3:
                    message.use = reader.int32();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* uint64 size */ 5:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* uint64 created_at */ 6:
                    message.createdAt = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 7:
                    message.updatedAt = reader.uint64().toBigInt();
                    break;
                case /* gooseai.Request request */ 8:
                    message.request = Request.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* map<string, string> tags */ 9:
                    this.binaryReadMap9(message.tags, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: ProjectAsset["tags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ProjectAsset["tags"] | undefined, val: ProjectAsset["tags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field gooseai.ProjectAsset.tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ProjectAsset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string uri = 2; */
        if (message.uri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uri);
        /* gooseai.ProjectAssetUse use = 3; */
        if (message.use !== 0)
            writer.tag(3, WireType.Varint).int32(message.use);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* uint64 size = 5; */
        if (message.size !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.size);
        /* uint64 created_at = 6; */
        if (message.createdAt !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.createdAt);
        /* uint64 updated_at = 7; */
        if (message.updatedAt !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.updatedAt);
        /* gooseai.Request request = 8; */
        if (message.request)
            Request.internalBinaryWrite(message.request, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> tags = 9; */
        for (let k of Object.keys(message.tags))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.tags[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ProjectAsset
 */
export const ProjectAsset = new ProjectAsset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Project$Type extends MessageType<Project> {
    constructor() {
        super("gooseai.Project", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access", kind: "enum", T: () => ["gooseai.ProjectAccess", ProjectAccess, "PROJECT_ACCESS_"] },
            { no: 5, name: "status", kind: "enum", T: () => ["gooseai.ProjectStatus", ProjectStatus, "PROJECT_STATUS_"] },
            { no: 6, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "file", kind: "message", T: () => ProjectAsset },
            { no: 8, name: "created_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "updated_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "assets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ProjectAsset }
        ]);
    }
    create(value?: PartialMessage<Project>): Project {
        const message = { id: "", title: "", ownerId: "", access: 0, status: 0, size: 0n, createdAt: 0n, updatedAt: 0n, assets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Project>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Project): Project {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string owner_id */ 3:
                    message.ownerId = reader.string();
                    break;
                case /* gooseai.ProjectAccess access */ 4:
                    message.access = reader.int32();
                    break;
                case /* gooseai.ProjectStatus status */ 5:
                    message.status = reader.int32();
                    break;
                case /* uint64 size */ 6:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* gooseai.ProjectAsset file */ 7:
                    message.file = ProjectAsset.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                case /* uint64 created_at */ 8:
                    message.createdAt = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 9:
                    message.updatedAt = reader.uint64().toBigInt();
                    break;
                case /* repeated gooseai.ProjectAsset assets */ 10:
                    message.assets.push(ProjectAsset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Project, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string owner_id = 3; */
        if (message.ownerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ownerId);
        /* gooseai.ProjectAccess access = 4; */
        if (message.access !== 0)
            writer.tag(4, WireType.Varint).int32(message.access);
        /* gooseai.ProjectStatus status = 5; */
        if (message.status !== 0)
            writer.tag(5, WireType.Varint).int32(message.status);
        /* uint64 size = 6; */
        if (message.size !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.size);
        /* gooseai.ProjectAsset file = 7; */
        if (message.file)
            ProjectAsset.internalBinaryWrite(message.file, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* uint64 created_at = 8; */
        if (message.createdAt !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.createdAt);
        /* uint64 updated_at = 9; */
        if (message.updatedAt !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.updatedAt);
        /* repeated gooseai.ProjectAsset assets = 10; */
        for (let i = 0; i < message.assets.length; i++)
            ProjectAsset.internalBinaryWrite(message.assets[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.Project
 */
export const Project = new Project$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateProjectRequest$Type extends MessageType<CreateProjectRequest> {
    constructor() {
        super("gooseai.CreateProjectRequest", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "access", kind: "enum", T: () => ["gooseai.ProjectAccess", ProjectAccess, "PROJECT_ACCESS_"] },
            { no: 4, name: "status", kind: "enum", T: () => ["gooseai.ProjectStatus", ProjectStatus, "PROJECT_STATUS_"] },
            { no: 5, name: "file", kind: "message", T: () => ProjectAsset }
        ]);
    }
    create(value?: PartialMessage<CreateProjectRequest>): CreateProjectRequest {
        const message = { title: "", access: 0, status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateProjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateProjectRequest): CreateProjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* gooseai.ProjectAccess access */ 3:
                    message.access = reader.int32();
                    break;
                case /* gooseai.ProjectStatus status */ 4:
                    message.status = reader.int32();
                    break;
                case /* optional gooseai.ProjectAsset file */ 5:
                    message.file = ProjectAsset.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateProjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* gooseai.ProjectAccess access = 3; */
        if (message.access !== 0)
            writer.tag(3, WireType.Varint).int32(message.access);
        /* gooseai.ProjectStatus status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* optional gooseai.ProjectAsset file = 5; */
        if (message.file)
            ProjectAsset.internalBinaryWrite(message.file, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.CreateProjectRequest
 */
export const CreateProjectRequest = new CreateProjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProjectRequest$Type extends MessageType<UpdateProjectRequest> {
    constructor() {
        super("gooseai.UpdateProjectRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "access", kind: "enum", opt: true, T: () => ["gooseai.ProjectAccess", ProjectAccess, "PROJECT_ACCESS_"] },
            { no: 5, name: "status", kind: "enum", opt: true, T: () => ["gooseai.ProjectStatus", ProjectStatus, "PROJECT_STATUS_"] },
            { no: 6, name: "file", kind: "message", T: () => ProjectAsset }
        ]);
    }
    create(value?: PartialMessage<UpdateProjectRequest>): UpdateProjectRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateProjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProjectRequest): UpdateProjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* optional string title */ 3:
                    message.title = reader.string();
                    break;
                case /* optional gooseai.ProjectAccess access */ 4:
                    message.access = reader.int32();
                    break;
                case /* optional gooseai.ProjectStatus status */ 5:
                    message.status = reader.int32();
                    break;
                case /* optional gooseai.ProjectAsset file */ 6:
                    message.file = ProjectAsset.internalBinaryRead(reader, reader.uint32(), options, message.file);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* optional string title = 3; */
        if (message.title !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.title);
        /* optional gooseai.ProjectAccess access = 4; */
        if (message.access !== undefined)
            writer.tag(4, WireType.Varint).int32(message.access);
        /* optional gooseai.ProjectStatus status = 5; */
        if (message.status !== undefined)
            writer.tag(5, WireType.Varint).int32(message.status);
        /* optional gooseai.ProjectAsset file = 6; */
        if (message.file)
            ProjectAsset.internalBinaryWrite(message.file, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.UpdateProjectRequest
 */
export const UpdateProjectRequest = new UpdateProjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListProjectRequest$Type extends MessageType<ListProjectRequest> {
    constructor() {
        super("gooseai.ListProjectRequest", [
            { no: 1, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListProjectRequest>): ListProjectRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListProjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListProjectRequest): ListProjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string owner_id */ 1:
                    message.ownerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListProjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string owner_id = 1; */
        if (message.ownerId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.ListProjectRequest
 */
export const ListProjectRequest = new ListProjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProjectRequest$Type extends MessageType<GetProjectRequest> {
    constructor() {
        super("gooseai.GetProjectRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetProjectRequest>): GetProjectRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetProjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProjectRequest): GetProjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.GetProjectRequest
 */
export const GetProjectRequest = new GetProjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteProjectRequest$Type extends MessageType<DeleteProjectRequest> {
    constructor() {
        super("gooseai.DeleteProjectRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteProjectRequest>): DeleteProjectRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteProjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteProjectRequest): DeleteProjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteProjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.DeleteProjectRequest
 */
export const DeleteProjectRequest = new DeleteProjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAssetsRequest$Type extends MessageType<QueryAssetsRequest> {
    constructor() {
        super("gooseai.QueryAssetsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "since", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "until", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "limit", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "start_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "use", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["gooseai.ProjectAssetUse", ProjectAssetUse, "PROJECT_ASSET_USE_"] },
            { no: 8, name: "sort_dir", kind: "enum", T: () => ["gooseai.ProjectSortDir", ProjectSortDir, "PROJECT_SORT_DIR_"] },
            { no: 9, name: "tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<QueryAssetsRequest>): QueryAssetsRequest {
        const message = { id: "", use: [], sortDir: 0, tags: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAssetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAssetsRequest): QueryAssetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* optional uint64 since */ 3:
                    message.since = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 until */ 4:
                    message.until = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 limit */ 5:
                    message.limit = reader.uint64().toBigInt();
                    break;
                case /* optional string start_key */ 6:
                    message.startKey = reader.string();
                    break;
                case /* repeated gooseai.ProjectAssetUse use */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.use.push(reader.int32());
                    else
                        message.use.push(reader.int32());
                    break;
                case /* gooseai.ProjectSortDir sort_dir */ 8:
                    message.sortDir = reader.int32();
                    break;
                case /* map<string, string> tags */ 9:
                    this.binaryReadMap9(message.tags, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap9(map: QueryAssetsRequest["tags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryAssetsRequest["tags"] | undefined, val: QueryAssetsRequest["tags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field gooseai.QueryAssetsRequest.tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: QueryAssetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* optional uint64 since = 3; */
        if (message.since !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.since);
        /* optional uint64 until = 4; */
        if (message.until !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.until);
        /* optional uint64 limit = 5; */
        if (message.limit !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.limit);
        /* optional string start_key = 6; */
        if (message.startKey !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.startKey);
        /* repeated gooseai.ProjectAssetUse use = 7; */
        if (message.use.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.use.length; i++)
                writer.int32(message.use[i]);
            writer.join();
        }
        /* gooseai.ProjectSortDir sort_dir = 8; */
        if (message.sortDir !== 0)
            writer.tag(8, WireType.Varint).int32(message.sortDir);
        /* map<string, string> tags = 9; */
        for (let k of Object.keys(message.tags))
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.tags[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.QueryAssetsRequest
 */
export const QueryAssetsRequest = new QueryAssetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAssetsResponse$Type extends MessageType<QueryAssetsResponse> {
    constructor() {
        super("gooseai.QueryAssetsResponse", [
            { no: 1, name: "assets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ProjectAsset },
            { no: 2, name: "last_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryAssetsResponse>): QueryAssetsResponse {
        const message = { assets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAssetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAssetsResponse): QueryAssetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseai.ProjectAsset assets */ 1:
                    message.assets.push(ProjectAsset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string last_key */ 2:
                    message.lastKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAssetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseai.ProjectAsset assets = 1; */
        for (let i = 0; i < message.assets.length; i++)
            ProjectAsset.internalBinaryWrite(message.assets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string last_key = 2; */
        if (message.lastKey !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.lastKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.QueryAssetsResponse
 */
export const QueryAssetsResponse = new QueryAssetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagAssetsRequest$Type extends MessageType<TagAssetsRequest> {
    constructor() {
        super("gooseai.TagAssetsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "asset_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<TagAssetsRequest>): TagAssetsRequest {
        const message = { id: "", assetIds: [], tags: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TagAssetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagAssetsRequest): TagAssetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* repeated string asset_ids */ 3:
                    message.assetIds.push(reader.string());
                    break;
                case /* map<string, string> tags */ 4:
                    this.binaryReadMap4(message.tags, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: TagAssetsRequest["tags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TagAssetsRequest["tags"] | undefined, val: TagAssetsRequest["tags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field gooseai.TagAssetsRequest.tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TagAssetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* repeated string asset_ids = 3; */
        for (let i = 0; i < message.assetIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.assetIds[i]);
        /* map<string, string> tags = 4; */
        for (let k of Object.keys(message.tags))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.tags[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TagAssetsRequest
 */
export const TagAssetsRequest = new TagAssetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagAssetsResponse$Type extends MessageType<TagAssetsResponse> {
    constructor() {
        super("gooseai.TagAssetsResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "asset_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagAssetsResponse>): TagAssetsResponse {
        const message = { id: "", ownerId: "", assetIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TagAssetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagAssetsResponse): TagAssetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* repeated string asset_ids */ 3:
                    message.assetIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagAssetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string owner_id = 2; */
        if (message.ownerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* repeated string asset_ids = 3; */
        for (let i = 0; i < message.assetIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.assetIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.TagAssetsResponse
 */
export const TagAssetsResponse = new TagAssetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UntagAssetsRequest$Type extends MessageType<UntagAssetsRequest> {
    constructor() {
        super("gooseai.UntagAssetsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "asset_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tag_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UntagAssetsRequest>): UntagAssetsRequest {
        const message = { id: "", assetIds: [], tagKeys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UntagAssetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UntagAssetsRequest): UntagAssetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* repeated string asset_ids */ 3:
                    message.assetIds.push(reader.string());
                    break;
                case /* repeated string tag_keys */ 4:
                    message.tagKeys.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UntagAssetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* repeated string asset_ids = 3; */
        for (let i = 0; i < message.assetIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.assetIds[i]);
        /* repeated string tag_keys = 4; */
        for (let i = 0; i < message.tagKeys.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.tagKeys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.UntagAssetsRequest
 */
export const UntagAssetsRequest = new UntagAssetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UntagAssetsResponse$Type extends MessageType<UntagAssetsResponse> {
    constructor() {
        super("gooseai.UntagAssetsResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "asset_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UntagAssetsResponse>): UntagAssetsResponse {
        const message = { id: "", ownerId: "", assetIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UntagAssetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UntagAssetsResponse): UntagAssetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* repeated string asset_ids */ 3:
                    message.assetIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UntagAssetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string owner_id = 2; */
        if (message.ownerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* repeated string asset_ids = 3; */
        for (let i = 0; i < message.assetIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.assetIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.UntagAssetsResponse
 */
export const UntagAssetsResponse = new UntagAssetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAssetsRequest$Type extends MessageType<DeleteAssetsRequest> {
    constructor() {
        super("gooseai.DeleteAssetsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "asset_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAssetsRequest>): DeleteAssetsRequest {
        const message = { id: "", assetIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteAssetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAssetsRequest): DeleteAssetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* repeated string asset_ids */ 3:
                    message.assetIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAssetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string owner_id = 2; */
        if (message.ownerId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* repeated string asset_ids = 3; */
        for (let i = 0; i < message.assetIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.assetIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.DeleteAssetsRequest
 */
export const DeleteAssetsRequest = new DeleteAssetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteAssetsResponse$Type extends MessageType<DeleteAssetsResponse> {
    constructor() {
        super("gooseai.DeleteAssetsResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "asset_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteAssetsResponse>): DeleteAssetsResponse {
        const message = { id: "", ownerId: "", assetIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteAssetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteAssetsResponse): DeleteAssetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string owner_id */ 2:
                    message.ownerId = reader.string();
                    break;
                case /* repeated string asset_ids */ 3:
                    message.assetIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteAssetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string owner_id = 2; */
        if (message.ownerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ownerId);
        /* repeated string asset_ids = 3; */
        for (let i = 0; i < message.assetIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.assetIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseai.DeleteAssetsResponse
 */
export const DeleteAssetsResponse = new DeleteAssetsResponse$Type();
/**
 * @generated ServiceType for protobuf service gooseai.ProjectService
 */
export const ProjectService = new ServiceType("gooseai.ProjectService", [
    { name: "Create", options: {}, I: CreateProjectRequest, O: Project },
    { name: "Update", options: {}, I: UpdateProjectRequest, O: Project },
    { name: "List", serverStreaming: true, options: {}, I: ListProjectRequest, O: Project },
    { name: "Get", options: {}, I: GetProjectRequest, O: Project },
    { name: "Delete", options: {}, I: DeleteProjectRequest, O: Project },
    { name: "TagAssets", options: {}, I: TagAssetsRequest, O: TagAssetsResponse },
    { name: "UntagAssets", options: {}, I: UntagAssetsRequest, O: UntagAssetsResponse },
    { name: "QueryAssets", options: {}, I: QueryAssetsRequest, O: QueryAssetsResponse },
    { name: "DeleteAssets", options: {}, I: DeleteAssetsRequest, O: DeleteAssetsResponse }
]);
